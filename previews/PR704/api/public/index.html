<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API Reference · PowerSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">PowerSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome Page</a></li><li><a class="tocitem" href="../../quick_start_guide/">Quick Start Guide</a></li><li><a class="tocitem" href="../../tutorials/intro_page/">Tutorials</a></li><li><span class="tocitem">Modeler Guide</span><ul><li><a class="tocitem" href="../../modeler_guide/type_structure/">Type Structure</a></li><li><a class="tocitem" href="../../modeler_guide/system/">System</a></li><li><a class="tocitem" href="../../modeler_guide/time_series/">Time Series Data</a></li><li><a class="tocitem" href="../../modeler_guide/example_dynamic_data/">Dynamic Devices</a></li><li><a class="tocitem" href="../../modeler_guide/system_dynamic_data/">Creating a System with Dynamic devices</a></li><li><a class="tocitem" href="../../modeler_guide/market_bid_cost/">PowerSystems <code>MarketBidCost</code></a></li><li><a class="tocitem" href="../../modeler_guide/generated_modeling_with_JuMP/">Modeling With Jump</a></li><li><a class="tocitem" href="../../modeler_guide/generated_network_matrices/">Network Matrices</a></li><li><a class="tocitem" href="../../modeler_guide/generated_parsing/">Parsing</a></li><li><a class="tocitem" href="../../modeler_guide/generated_power_flow/">Power Flow</a></li></ul></li><li><span class="tocitem">Model Developer Guide</span><ul><li><a class="tocitem" href="../../model_developer_guide/extending_parsing/">Extending Parsing</a></li><li><a class="tocitem" href="../../model_developer_guide/adding_custom_types/">Adding Types</a></li><li><a class="tocitem" href="../../model_developer_guide/generated_adding_additional_fields/">Adding Additional Fields</a></li></ul></li><li><span class="tocitem">Code Base Developer Guide</span><ul><li><a class="tocitem" href="../../code_base_developer_guide/developer/">Developer Guide</a></li><li><a class="tocitem" href="../../code_base_developer_guide/adding_new_types/">Adding New Types</a></li><li><a class="tocitem" href="../../code_base_developer_guide/troubleshooting/">Troubleshooting</a></li></ul></li><li><span class="tocitem">Model Library</span><ul><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">DeviceParameter</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/generated_MarketBidCost/">MarketBidCost</a></li><li><a class="tocitem" href="../../model_library/generated_MultiStartCost/">MultiStartCost</a></li><li><a class="tocitem" href="../../model_library/generated_ThreePartCost/">ThreePartCost</a></li><li><a class="tocitem" href="../../model_library/generated_TwoPartCost/">TwoPartCost</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">DynamicInverterComponent</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/generated_Converter/">Converter</a></li><li><a class="tocitem" href="../../model_library/generated_DCSource/">DCSource</a></li><li><a class="tocitem" href="../../model_library/generated_Filter/">Filter</a></li><li><a class="tocitem" href="../../model_library/generated_FrequencyEstimator/">FrequencyEstimator</a></li><li><a class="tocitem" href="../../model_library/generated_InnerControl/">InnerControl</a></li><li><a class="tocitem" href="../../model_library/outer_control/">OuterControl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">StaticInjection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/generated_InterruptibleLoad/">InterruptibleLoad</a></li><li><a class="tocitem" href="../../model_library/generated_FixedAdmittance/">FixedAdmittance</a></li><li><a class="tocitem" href="../../model_library/generated_PowerLoad/">PowerLoad</a></li><li><a class="tocitem" href="../../model_library/generated_HydroDispatch/">HydroDispatch</a></li><li><a class="tocitem" href="../../model_library/generated_HydroEnergyReservoir/">HydroEnergyReservoir</a></li><li><a class="tocitem" href="../../model_library/generated_HydroPumpedStorage/">HydroPumpedStorage</a></li><li><a class="tocitem" href="../../model_library/generated_RenewableDispatch/">RenewableDispatch</a></li><li><a class="tocitem" href="../../model_library/generated_RenewableFix/">RenewableFix</a></li><li><a class="tocitem" href="../../model_library/generated_ThermalMultiStart/">ThermalMultiStart</a></li><li><a class="tocitem" href="../../model_library/generated_ThermalStandard/">ThermalStandard</a></li><li><a class="tocitem" href="../../model_library/generated_HybridSystem/">HybridSystem</a></li><li><a class="tocitem" href="../../model_library/generated_Source/">Source</a></li><li><a class="tocitem" href="../../model_library/generated_BatteryEMS/">BatteryEMS</a></li><li><a class="tocitem" href="../../model_library/generated_GenericBattery/">GenericBattery</a></li><li><a class="tocitem" href="../../model_library/hybrid_device/">HybridSystem</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-4" type="checkbox"/><label class="tocitem" for="menuitem-7-4"><span class="docs-label">Topology</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/generated_Area/">Area</a></li><li><a class="tocitem" href="../../model_library/generated_LoadZone/">LoadZone</a></li><li><a class="tocitem" href="../../model_library/generated_Arc/">Arc</a></li><li><a class="tocitem" href="../../model_library/generated_Bus/">Bus</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-5" type="checkbox"/><label class="tocitem" for="menuitem-7-5"><span class="docs-label">DynamicInjection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/dynamic_inverter/">Dynamic Inverter</a></li><li><a class="tocitem" href="../../model_library/dynamic_generator/">Dynamic Generator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">Service</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/generated_AGC/">AGC</a></li><li><a class="tocitem" href="../../model_library/generated_StaticReserveNonSpinning/">StaticReserveNonSpinning</a></li><li><a class="tocitem" href="../../model_library/generated_VariableReserveNonSpinning/">VariableReserveNonSpinning</a></li><li><a class="tocitem" href="../../model_library/generated_Transfer/">Transfer</a></li><li><a class="tocitem" href="../../model_library/reserves/">Reserves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-7" type="checkbox"/><label class="tocitem" for="menuitem-7-7"><span class="docs-label">Branch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/generated_Line/">Line</a></li><li><a class="tocitem" href="../../model_library/generated_MonitoredLine/">MonitoredLine</a></li><li><a class="tocitem" href="../../model_library/generated_PhaseShiftingTransformer/">PhaseShiftingTransformer</a></li><li><a class="tocitem" href="../../model_library/generated_TapTransformer/">TapTransformer</a></li><li><a class="tocitem" href="../../model_library/generated_Transformer2W/">Transformer2W</a></li><li><a class="tocitem" href="../../model_library/generated_HVDCLine/">HVDCLine</a></li><li><a class="tocitem" href="../../model_library/generated_VSCDCLine/">VSCDCLine</a></li><li><a class="tocitem" href="../../model_library/dynamic_branch/">Dynamic Lines</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-8" type="checkbox"/><label class="tocitem" for="menuitem-7-8"><span class="docs-label">DynamicGeneratorComponent</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/generated_AVR/">AVR</a></li><li><a class="tocitem" href="../../model_library/generated_Machine/">Machine</a></li><li><a class="tocitem" href="../../model_library/generated_PSS/">PSS</a></li><li><a class="tocitem" href="../../model_library/generated_Shaft/">Shaft</a></li><li><a class="tocitem" href="../../model_library/generated_TurbineGov/">TurbineGov</a></li></ul></li></ul></li><li class="is-active"><a class="tocitem" href>Public API Reference</a><ul class="internal"><li><a class="tocitem" href="#Modeling"><span>Modeling</span></a></li><li><a class="tocitem" href="#TimeSeries"><span>TimeSeries</span></a></li><li><a class="tocitem" href="#System"><span>System</span></a></li><li><a class="tocitem" href="#Additional-Component-Methods"><span>Additional Component Methods</span></a></li><li><a class="tocitem" href="#net_mat"><span>Network Matrices</span></a></li><li><a class="tocitem" href="#pf"><span>Power Flow</span></a></li><li><a class="tocitem" href="#Parsing"><span>Parsing</span></a></li><li><a class="tocitem" href="#logging"><span>Logging</span></a></li></ul></li><li><a class="tocitem" href="../internal/">Internal API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/master/docs/src/api/public.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API-Reference"><a class="docs-heading-anchor" href="#Public-API-Reference">Public API Reference</a><a id="Public-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API-Reference" title="Permalink"></a></h1><h2 id="Modeling"><a class="docs-heading-anchor" href="#Modeling">Modeling</a><a id="Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PowerSystems" href="#PowerSystems.PowerSystems"><code>PowerSystems.PowerSystems</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module for constructing self-contained power system objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/PowerSystems.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Component" href="#PowerSystems.Component"><code>PowerSystems.Component</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for all PowerSystems components. All subtypes must include a InfrastructureSystemsInternal member. Subtypes should call InfrastructureSystemsInternal() by default, but also must provide a constructor that allows existing values to be deserialized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/PowerSystems.jl#L414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Device" href="#PowerSystems.Device"><code>PowerSystems.Device</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for &quot;devices&quot; (bus, line, etc.) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/PowerSystems.jl#L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_base_power-Tuple{Component}" href="#PowerSystems.get_base_power-Tuple{Component}"><code>PowerSystems.get_base_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_base_power(c::Component) -&gt; Float64
</code></pre><pre><code class="language-none">Default behavior of a component. If there is no base_power field, assume is in the system&#39;s base power.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/components.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_dynamic_injector!-Union{Tuple{U}, Tuple{T}, Tuple{T,U}} where U&lt;:Union{Nothing, DynamicInjection} where T&lt;:StaticInjection" href="#PowerSystems.set_dynamic_injector!-Union{Tuple{U}, Tuple{T}, Tuple{T,U}} where U&lt;:Union{Nothing, DynamicInjection} where T&lt;:StaticInjection"><code>PowerSystems.set_dynamic_injector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_dynamic_injector!(static_injector::T&lt;:StaticInjection, dynamic_injector::U&lt;:Union{Nothing, DynamicInjection}) -&gt; Union{Nothing, DynamicInjection}
</code></pre><p>Any StaticInjection struct that wants to support dynamic injectors must implement this method to set the value.</p><p>The method is only for internal uses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/injection.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.clear_services!-Tuple{Device}" href="#PowerSystems.clear_services!-Tuple{Device}"><code>PowerSystems.clear_services!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear_services!(device::Device) -&gt; Any
</code></pre><p>Remove all services attached to the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/devices.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.has_service-Tuple{Device,Service}" href="#PowerSystems.has_service-Tuple{Device,Service}"><code>PowerSystems.has_service</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_service(device::Device, service::Service) -&gt; Bool
</code></pre><p>Return true if the service is attached to the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/devices.jl#L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.has_service-Union{Tuple{T}, Tuple{Device,Type{T}}} where T&lt;:Service" href="#PowerSystems.has_service-Union{Tuple{T}, Tuple{Device,Type{T}}} where T&lt;:Service"><code>PowerSystems.has_service</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_service(device::Device, _::Type{T&lt;:Service}) -&gt; Bool
</code></pre><p>Return true if a service with type T is attached to the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/devices.jl#L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.remove_service!-Tuple{Device,Service}" href="#PowerSystems.remove_service!-Tuple{Device,Service}"><code>PowerSystems.remove_service!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">remove_service!(device::Device, service::Service)
</code></pre><p>Remove a service from a device.</p><p>Throws ArgumentError if the service is not attached to the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/devices.jl#L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Generator" href="#PowerSystems.Generator"><code>PowerSystems.Generator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for all generation technologies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/generation.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.HydroGen" href="#PowerSystems.HydroGen"><code>PowerSystems.HydroGen</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for all Hydropower generation technologies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/generation.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.RenewableGen" href="#PowerSystems.RenewableGen"><code>PowerSystems.RenewableGen</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for all renewable generation technologies Requires the implementation of <code>get_rating</code>and <code>get_power_factor</code> methods</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/generation.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.ThermalGen" href="#PowerSystems.ThermalGen"><code>PowerSystems.ThermalGen</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Supertype for all Thermal generation technologies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/generation.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_max_active_power-Union{Tuple{T}, Tuple{T}} where T&lt;:RenewableGen" href="#PowerSystems.get_max_active_power-Union{Tuple{T}, Tuple{T}} where T&lt;:RenewableGen"><code>PowerSystems.get_max_active_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_max_active_power(d::T&lt;:RenewableGen) -&gt; Any
</code></pre><p>Return the max active power for the Renewable Generation calculated as the rating * power_factor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/generation.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_max_reactive_power-Union{Tuple{T}, Tuple{T}} where T&lt;:RenewableGen" href="#PowerSystems.get_max_reactive_power-Union{Tuple{T}, Tuple{T}} where T&lt;:RenewableGen"><code>PowerSystems.get_max_reactive_power</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the max reactive power for the Renewable Generation calculated as the rating * power_factor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/generation.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.AggregationTopology" href="#PowerSystems.AggregationTopology"><code>PowerSystems.AggregationTopology</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Represents a geographical region of system components.</p><p>All subtypes must implement the method <code>get_aggregation_topology_accessor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/topological_elements.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Topology" href="#PowerSystems.Topology"><code>PowerSystems.Topology</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type to represent the structure and interconnectedness of the system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/topological_elements.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_aggregation_topology_accessor-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AggregationTopology" href="#PowerSystems.get_aggregation_topology_accessor-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AggregationTopology"><code>PowerSystems.get_aggregation_topology_accessor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_aggregation_topology_accessor(_::Type{T&lt;:AggregationTopology}) -&gt; typeof(get_area)
</code></pre><p>Return the method to be called on a Bus to get its AggregationTopology value for this type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/topological_elements.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.StaticInjection" href="#PowerSystems.StaticInjection"><code>PowerSystems.StaticInjection</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type of Devices that inject current/power </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/static_models.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.DynamicComponent" href="#PowerSystems.DynamicComponent"><code>PowerSystems.DynamicComponent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for all components used to compose a <a href="#PowerSystems.DynamicInjection"><code>DynamicInjection</code></a> device</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/dynamic_models.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.DynamicInjection" href="#PowerSystems.DynamicInjection"><code>PowerSystems.DynamicInjection</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for all dynamic injection types</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/dynamic_models.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_dynamic_components-Union{Tuple{T}, Tuple{T}} where T&lt;:DynamicInjection" href="#PowerSystems.get_dynamic_components-Union{Tuple{T}, Tuple{T}} where T&lt;:DynamicInjection"><code>PowerSystems.get_dynamic_components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_dynamic_components(device::T&lt;:DynamicInjection) -&gt; Base.Generator{_A,_B} where _B where _A
</code></pre><p>Return all the dynamic components of a <a href="#PowerSystems.DynamicInjection"><code>DynamicInjection</code></a> device</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/dynamic_models.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_states_types-Tuple{DynamicComponent}" href="#PowerSystems.get_states_types-Tuple{DynamicComponent}"><code>PowerSystems.get_states_types</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_states_types(d::DynamicComponent) -&gt; Array{StateTypes,1}
</code></pre><pre><code class="language-none">Default implementation of get_state_types for dynamic components. Assumes all states are
Differential</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/dynamic_models.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_breakpoint_upperbounds-Tuple{VariableCost{Array{Tuple{Float64,Float64},1}}}" href="#PowerSystems.get_breakpoint_upperbounds-Tuple{VariableCost{Array{Tuple{Float64,Float64},1}}}"><code>PowerSystems.get_breakpoint_upperbounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_breakpoint_upperbounds(vc::VariableCost{Array{Tuple{Float64,Float64},1}}) -&gt; Array{Float64,1}
</code></pre><p>Calculates the upper bounds of a variable cost function represented as a collection of piece-wise linear segments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/operational_cost.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_slopes-Tuple{VariableCost{Array{Tuple{Float64,Float64},1}}}" href="#PowerSystems.get_slopes-Tuple{VariableCost{Array{Tuple{Float64,Float64},1}}}"><code>PowerSystems.get_slopes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_slopes(vc::VariableCost{Array{Tuple{Float64,Float64},1}}) -&gt; Array{Float64,1}
</code></pre><p>Calculates the slopes for the variable cost represented as a piece wise linear cost function. This function returns n - slopes for n - piecewise linear elements in the function. The first element of the return array corresponds to the average cost at the minimum operating point. If your formulation uses n -1 slopes, you can disregard the first component of the array. If the first point in the variable cost has a quantity of 0.0, the first slope returned will be 0.0, otherwise, the first slope represents the trajectory to get from the origin to the first point in the variable cost.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/operational_cost.jl#L66">source</a></section></article><h2 id="TimeSeries"><a class="docs-heading-anchor" href="#TimeSeries">TimeSeries</a><a id="TimeSeries-1"></a><a class="docs-heading-anchor-permalink" href="#TimeSeries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.TimeSeriesData" href="#InfrastructureSystems.TimeSeriesData"><code>InfrastructureSystems.TimeSeriesData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for time series stored in the system. Components store references to these through TimeSeriesMetadata values so that data can reside on storage media instead of memory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.TimeSeriesMetadata" href="#InfrastructureSystems.TimeSeriesMetadata"><code>InfrastructureSystems.TimeSeriesMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for time_series that are stored in a system. Users never create them or get access to them. Stores references to TimeSeriesData.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Deterministic" href="#InfrastructureSystems.Deterministic"><code>InfrastructureSystems.Deterministic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Deterministic &lt;: AbstractDeterministic
    name::String
    data::Union{
        SortedDict{Dates.DateTime, Vector{CONSTANT}},
        SortedDict{Dates.DateTime, Vector{POLYNOMIAL}},
        SortedDict{Dates.DateTime, Vector{PWL}},
    }
    resolution::Dates.Period
    scaling_factor_multiplier::Union{Nothing, Function}
    internal::InfrastructureSystemsInternal
end</code></pre><p>A deterministic forecast for a particular data field in a Component.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: user-defined name</li><li><code>data::Union{SortedDict{Dates.DateTime, Vector{CONSTANT}}, SortedDict{Dates.DateTime, Vector{POLYNOMIAL}}, SortedDict{Dates.DateTime, Vector{PWL}}}</code>: timestamp - scalingfactor</li><li><code>resolution::Dates.Period</code>: forecast resolution</li><li><code>scaling_factor_multiplier::Union{Nothing, Function}</code>: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.</li><li><code>internal::InfrastructureSystemsInternal</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Deterministic-Tuple{AbstractString,AbstractDict{Dates.DateTime,#s63} where #s63&lt;:TimeSeries.TimeArray}" href="#InfrastructureSystems.Deterministic-Tuple{AbstractString,AbstractDict{Dates.DateTime,#s63} where #s63&lt;:TimeSeries.TimeArray}"><code>InfrastructureSystems.Deterministic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Deterministic(name::AbstractString, input_data::AbstractDict{Dates.DateTime,#s63} where #s63&lt;:TimeSeries.TimeArray; normalization_factor, scaling_factor_multiplier) -&gt; Deterministic
</code></pre><p>Construct Deterministic from a Dict of TimeArrays.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>input_data::AbstractDict{Dates.DateTime, TimeSeries.TimeArray}</code>: time series data.</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li><li><code>timestamp = :timestamp</code>: If the values are DataFrames is passed then this must be the column name that contains timestamps.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Deterministic-Tuple{AbstractString,AbstractString,InfrastructureSystems.InfrastructureSystemsComponent,Dates.Period}" href="#InfrastructureSystems.Deterministic-Tuple{AbstractString,AbstractString,InfrastructureSystems.InfrastructureSystemsComponent,Dates.Period}"><code>InfrastructureSystems.Deterministic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Deterministic(name::AbstractString, filename::AbstractString, component::InfrastructureSystems.InfrastructureSystemsComponent, resolution::Dates.Period; normalization_factor, scaling_factor_multiplier) -&gt; Deterministic
</code></pre><p>Construct Deterministic from a CSV file. The first column must be a timestamp in DateTime format and the columns the values in the forecast window.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>filename::AbstractString</code>: name of CSV file containing data</li><li><code>component::InfrastructureSystemsComponent</code>: component associated with the data</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Deterministic-Tuple{AbstractString,InfrastructureSystems.RawTimeSeries,Dates.Period}" href="#InfrastructureSystems.Deterministic-Tuple{AbstractString,InfrastructureSystems.RawTimeSeries,Dates.Period}"><code>InfrastructureSystems.Deterministic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Deterministic(name::AbstractString, series_data::InfrastructureSystems.RawTimeSeries, resolution::Dates.Period; normalization_factor, scaling_factor_multiplier) -&gt; Deterministic
</code></pre><p>Construct Deterministic from RawTimeSeries.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Deterministic-Tuple{Deterministic,Any}" href="#InfrastructureSystems.Deterministic-Tuple{Deterministic,Any}"><code>InfrastructureSystems.Deterministic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Deterministic(forecast::Deterministic, data::Any) -&gt; Deterministic
</code></pre><p>Construct a new Deterministic from an existing instance and a subset of data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_data-Tuple{Deterministic}" href="#InfrastructureSystems.get_data-Tuple{Deterministic}"><code>InfrastructureSystems.get_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_data(value::Deterministic) -&gt; Union{DataStructures.SortedDict{Dates.DateTime,Array{Array{Tuple{Float64,Float64},1},1},Ord} where Ord&lt;:Base.Order.Ordering, DataStructures.SortedDict{Dates.DateTime,Array{Float64,1},Ord} where Ord&lt;:Base.Order.Ordering, DataStructures.SortedDict{Dates.DateTime,Array{Tuple{Float64,Float64},1},Ord} where Ord&lt;:Base.Order.Ordering}
</code></pre><p>Get <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_name-Tuple{Deterministic}" href="#InfrastructureSystems.get_name-Tuple{Deterministic}"><code>InfrastructureSystems.get_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_name(value::Deterministic) -&gt; String
</code></pre><p>Get <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_resolution-Tuple{Deterministic}" href="#InfrastructureSystems.get_resolution-Tuple{Deterministic}"><code>InfrastructureSystems.get_resolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_resolution(value::Deterministic) -&gt; Dates.Period
</code></pre><p>Get <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>resolution</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_scaling_factor_multiplier-Tuple{Deterministic}" href="#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{Deterministic}"><code>InfrastructureSystems.get_scaling_factor_multiplier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_scaling_factor_multiplier(value::Deterministic) -&gt; Union{Nothing, Function}
</code></pre><p>Get <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_data!-Tuple{Deterministic,Any}" href="#InfrastructureSystems.set_data!-Tuple{Deterministic,Any}"><code>InfrastructureSystems.set_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_data!(value::Deterministic, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_name!-Tuple{Deterministic,Any}" href="#InfrastructureSystems.set_name!-Tuple{Deterministic,Any}"><code>InfrastructureSystems.set_name!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_name!(value::Deterministic, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_resolution!-Tuple{Deterministic,Any}" href="#InfrastructureSystems.set_resolution!-Tuple{Deterministic,Any}"><code>InfrastructureSystems.set_resolution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_resolution!(value::Deterministic, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>resolution</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{Deterministic,Any}" href="#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{Deterministic,Any}"><code>InfrastructureSystems.set_scaling_factor_multiplier!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_scaling_factor_multiplier!(value::Deterministic, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Probabilistic" href="#InfrastructureSystems.Probabilistic"><code>InfrastructureSystems.Probabilistic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Probabilistic &lt;: Forecast
    name::String
    resolution::Dates.Period
    percentiles::Vector{Float64}
    data::Union{
        SortedDict{Dates.DateTime, Matrix{CONSTANT}},
        SortedDict{Dates.DateTime, Matrix{POLYNOMIAL}},
        SortedDict{Dates.DateTime, Matrix{PWL}},
    }
    scaling_factor_multiplier::Union{Nothing, Function}
    internal::InfrastructureSystemsInternal
end</code></pre><p>A Probabilistic forecast for a particular data field in a Component.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: user-defined name</li><li><code>resolution::Dates.Period</code>: forecast resolution</li><li><code>percentiles::Vector{Float64}</code>: Percentiles for the probabilistic forecast</li><li><code>data::Union{SortedDict{Dates.DateTime, Matrix{CONSTANT}}, SortedDict{Dates.DateTime, Matrix{POLYNOMIAL}}, SortedDict{Dates.DateTime, Matrix{PWL}}}</code>: timestamp - scalingfactor</li><li><code>scaling_factor_multiplier::Union{Nothing, Function}</code>: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.</li><li><code>internal::InfrastructureSystemsInternal</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Probabilistic-Tuple{AbstractString,AbstractDict,Array{T,1} where T,Dates.Period}" href="#InfrastructureSystems.Probabilistic-Tuple{AbstractString,AbstractDict,Array{T,1} where T,Dates.Period}"><code>InfrastructureSystems.Probabilistic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Probabilistic(name::AbstractString, input_data::AbstractDict, percentiles::Array{T,1} where T, resolution::Dates.Period; normalization_factor, scaling_factor_multiplier) -&gt; Probabilistic
</code></pre><p>Construct Probabilistic from a SortedDict of Arrays.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>input_data::AbstractDict{Dates.DateTime, Matrix{Float64}}</code>: time series data.</li><li><code>percentiles</code>: Percentiles represented in the probabilistic forecast</li><li><code>resolution::Dates.Period</code>: The resolution of the forecast in Dates.Period`</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Probabilistic-Tuple{AbstractString,AbstractDict{Dates.DateTime,#s63} where #s63&lt;:TimeSeries.TimeArray,Array{Float64,1}}" href="#InfrastructureSystems.Probabilistic-Tuple{AbstractString,AbstractDict{Dates.DateTime,#s63} where #s63&lt;:TimeSeries.TimeArray,Array{Float64,1}}"><code>InfrastructureSystems.Probabilistic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Probabilistic(name::AbstractString, input_data::AbstractDict{Dates.DateTime,#s63} where #s63&lt;:TimeSeries.TimeArray, percentiles::Array{Float64,1}; normalization_factor, scaling_factor_multiplier) -&gt; Probabilistic
</code></pre><p>Construct Probabilistic from a Dict of TimeArrays.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>input_data::AbstractDict{Dates.DateTime, TimeSeries.TimeArray}</code>: time series data.</li><li><code>percentiles</code>: Percentiles represented in the probabilistic forecast</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li><li><code>timestamp = :timestamp</code>: If the values are DataFrames is passed then this must be the column name that contains timestamps.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Probabilistic-Tuple{AbstractString,InfrastructureSystems.RawTimeSeries,Array{T,1} where T,Dates.Period}" href="#InfrastructureSystems.Probabilistic-Tuple{AbstractString,InfrastructureSystems.RawTimeSeries,Array{T,1} where T,Dates.Period}"><code>InfrastructureSystems.Probabilistic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Probabilistic(name::AbstractString, series_data::InfrastructureSystems.RawTimeSeries, percentiles::Array{T,1} where T, resolution::Dates.Period; normalization_factor, scaling_factor_multiplier) -&gt; Probabilistic
</code></pre><p>Construct Deterministic from RawTimeSeries.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_data-Tuple{Probabilistic}" href="#InfrastructureSystems.get_data-Tuple{Probabilistic}"><code>InfrastructureSystems.get_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_data(value::Probabilistic) -&gt; Union{DataStructures.SortedDict{Dates.DateTime,Array{Array{Tuple{Float64,Float64},1},2},Ord} where Ord&lt;:Base.Order.Ordering, DataStructures.SortedDict{Dates.DateTime,Array{Float64,2},Ord} where Ord&lt;:Base.Order.Ordering, DataStructures.SortedDict{Dates.DateTime,Array{Tuple{Float64,Float64},2},Ord} where Ord&lt;:Base.Order.Ordering}
</code></pre><p>Get <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_name-Tuple{Probabilistic}" href="#InfrastructureSystems.get_name-Tuple{Probabilistic}"><code>InfrastructureSystems.get_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_name(value::Probabilistic) -&gt; String
</code></pre><p>Get <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_percentiles-Tuple{Probabilistic}" href="#InfrastructureSystems.get_percentiles-Tuple{Probabilistic}"><code>InfrastructureSystems.get_percentiles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_percentiles(value::Probabilistic) -&gt; Array{Float64,1}
</code></pre><p>Get <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>percentiles</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_resolution-Tuple{Probabilistic}" href="#InfrastructureSystems.get_resolution-Tuple{Probabilistic}"><code>InfrastructureSystems.get_resolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_resolution(value::Probabilistic) -&gt; Dates.Period
</code></pre><p>Get <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>resolution</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_scaling_factor_multiplier-Tuple{Probabilistic}" href="#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{Probabilistic}"><code>InfrastructureSystems.get_scaling_factor_multiplier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_scaling_factor_multiplier(value::Probabilistic) -&gt; Union{Nothing, Function}
</code></pre><p>Get <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_data!-Tuple{Probabilistic,Any}" href="#InfrastructureSystems.set_data!-Tuple{Probabilistic,Any}"><code>InfrastructureSystems.set_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_data!(value::Probabilistic, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_name!-Tuple{Probabilistic,Any}" href="#InfrastructureSystems.set_name!-Tuple{Probabilistic,Any}"><code>InfrastructureSystems.set_name!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_name!(value::Probabilistic, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_percentiles!-Tuple{Probabilistic,Any}" href="#InfrastructureSystems.set_percentiles!-Tuple{Probabilistic,Any}"><code>InfrastructureSystems.set_percentiles!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_percentiles!(value::Probabilistic, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>percentiles</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_resolution!-Tuple{Probabilistic,Any}" href="#InfrastructureSystems.set_resolution!-Tuple{Probabilistic,Any}"><code>InfrastructureSystems.set_resolution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_resolution!(value::Probabilistic, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>resolution</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{Probabilistic,Any}" href="#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{Probabilistic,Any}"><code>InfrastructureSystems.set_scaling_factor_multiplier!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_scaling_factor_multiplier!(value::Probabilistic, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Scenarios" href="#InfrastructureSystems.Scenarios"><code>InfrastructureSystems.Scenarios</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Scenarios &lt;: Forecast
    name::String
    resolution::Dates.Period
    scenario_count::Int64
    data::Union{
        SortedDict{Dates.DateTime, Matrix{CONSTANT}},
        SortedDict{Dates.DateTime, Matrix{POLYNOMIAL}},
        SortedDict{Dates.DateTime, Matrix{PWL}},
    }
    scaling_factor_multiplier::Union{Nothing, Function}
    internal::InfrastructureSystemsInternal
end</code></pre><p>A Discrete Scenario Based time series for a particular data field in a Component.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: user-defined name</li><li><code>resolution::Dates.Period</code>: forecast resolution</li><li><code>scenario_count::Int64</code>: Number of scenarios</li><li><code>data::Union{SortedDict{Dates.DateTime, Matrix{CONSTANT}}, SortedDict{Dates.DateTime, Matrix{POLYNOMIAL}}, SortedDict{Dates.DateTime, Matrix{PWL}}}</code>: timestamp - scalingfactor</li><li><code>scaling_factor_multiplier::Union{Nothing, Function}</code>: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.</li><li><code>internal::InfrastructureSystemsInternal</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Scenarios-Tuple{AbstractString,AbstractDict,Dates.Period}" href="#InfrastructureSystems.Scenarios-Tuple{AbstractString,AbstractDict,Dates.Period}"><code>InfrastructureSystems.Scenarios</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Scenarios(name::AbstractString, input_data::AbstractDict, resolution::Dates.Period; normalization_factor, scaling_factor_multiplier) -&gt; Scenarios
</code></pre><p>Construct Scenarios from a SortedDict of Arrays.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>input_data::AbstractDict{Dates.DateTime, Matrix{Float64}}</code>: time series data.</li><li><code>resolution::Dates.Period</code>: The resolution of the forecast in Dates.Period`</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Scenarios-Tuple{AbstractString,AbstractDict{Dates.DateTime,#s63} where #s63&lt;:TimeSeries.TimeArray}" href="#InfrastructureSystems.Scenarios-Tuple{AbstractString,AbstractDict{Dates.DateTime,#s63} where #s63&lt;:TimeSeries.TimeArray}"><code>InfrastructureSystems.Scenarios</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Scenarios(name::AbstractString, input_data::AbstractDict{Dates.DateTime,#s63} where #s63&lt;:TimeSeries.TimeArray; normalization_factor, scaling_factor_multiplier) -&gt; Scenarios
</code></pre><p>Construct Scenarios from a Dict of TimeArrays.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>input_data::AbstractDict{Dates.DateTime, TimeSeries.TimeArray}</code>: time series data.</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li><li><code>timestamp = :timestamp</code>: If the values are DataFrames is passed then this must be the column name that contains timestamps.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_data-Tuple{Scenarios}" href="#InfrastructureSystems.get_data-Tuple{Scenarios}"><code>InfrastructureSystems.get_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_data(value::Scenarios) -&gt; Union{DataStructures.SortedDict{Dates.DateTime,Array{Array{Tuple{Float64,Float64},1},2},Ord} where Ord&lt;:Base.Order.Ordering, DataStructures.SortedDict{Dates.DateTime,Array{Float64,2},Ord} where Ord&lt;:Base.Order.Ordering, DataStructures.SortedDict{Dates.DateTime,Array{Tuple{Float64,Float64},2},Ord} where Ord&lt;:Base.Order.Ordering}
</code></pre><p>Get <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_name-Tuple{Scenarios}" href="#InfrastructureSystems.get_name-Tuple{Scenarios}"><code>InfrastructureSystems.get_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_name(value::Scenarios) -&gt; String
</code></pre><p>Get <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_resolution-Tuple{Scenarios}" href="#InfrastructureSystems.get_resolution-Tuple{Scenarios}"><code>InfrastructureSystems.get_resolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_resolution(value::Scenarios) -&gt; Dates.Period
</code></pre><p>Get <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>resolution</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_scaling_factor_multiplier-Tuple{Scenarios}" href="#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{Scenarios}"><code>InfrastructureSystems.get_scaling_factor_multiplier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_scaling_factor_multiplier(value::Scenarios) -&gt; Union{Nothing, Function}
</code></pre><p>Get <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_scenario_count-Tuple{Scenarios}" href="#InfrastructureSystems.get_scenario_count-Tuple{Scenarios}"><code>InfrastructureSystems.get_scenario_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_scenario_count(value::Scenarios) -&gt; Int64
</code></pre><p>Get <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>scenario_count</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_data!-Tuple{Scenarios,Any}" href="#InfrastructureSystems.set_data!-Tuple{Scenarios,Any}"><code>InfrastructureSystems.set_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_data!(value::Scenarios, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_name!-Tuple{Scenarios,Any}" href="#InfrastructureSystems.set_name!-Tuple{Scenarios,Any}"><code>InfrastructureSystems.set_name!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_name!(value::Scenarios, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_resolution!-Tuple{Scenarios,Any}" href="#InfrastructureSystems.set_resolution!-Tuple{Scenarios,Any}"><code>InfrastructureSystems.set_resolution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_resolution!(value::Scenarios, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>resolution</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{Scenarios,Any}" href="#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{Scenarios,Any}"><code>InfrastructureSystems.set_scaling_factor_multiplier!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_scaling_factor_multiplier!(value::Scenarios, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_scenario_count!-Tuple{Scenarios,Any}" href="#InfrastructureSystems.set_scenario_count!-Tuple{Scenarios,Any}"><code>InfrastructureSystems.set_scenario_count!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_scenario_count!(value::Scenarios, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>scenario_count</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.DeterministicSingleTimeSeries" href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>InfrastructureSystems.DeterministicSingleTimeSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct DeterministicSingleTimeSeries &lt;: AbstractDeterministic
    single_time_series::SingleTimeSeries
    initial_timestamp::Dates.DateTime
    interval::Dates.Period
    count::Int
    horizon::Int
end</code></pre><p>A deterministic forecast for a particular data field in a Component that wraps a SingleTimeSeries.</p><p><strong>Arguments</strong></p><ul><li><code>single_time_series::SingleTimeSeries</code>: wrapped SingleTimeSeries object</li><li><code>initial_timestamp::Dates.DateTime</code>: time series availability time</li><li><code>interval::Dates.Period</code>: time step between forecast windows</li><li><code>count::Int</code>: number of forecast windows</li><li><code>horizon::Int</code>: length of this time series</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.SingleTimeSeries" href="#InfrastructureSystems.SingleTimeSeries"><code>InfrastructureSystems.SingleTimeSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct SingleTimeSeries &lt;: StaticTimeSeries
    name::String
    data::TimeSeries.TimeArray
    scaling_factor_multiplier::Union{Nothing, Function}
    internal::InfrastructureSystemsInternal
end</code></pre><p>A deterministic forecast for a particular data field in a Component.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: user-defined name</li><li><code>data::TimeSeries.TimeArray</code>: timestamp - scalingfactor</li><li><code>scaling_factor_multiplier::Union{Nothing, Function}</code>: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.</li><li><code>internal::InfrastructureSystemsInternal</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.SingleTimeSeries-Tuple{AbstractString,AbstractString,InfrastructureSystems.InfrastructureSystemsComponent,Dates.Period}" href="#InfrastructureSystems.SingleTimeSeries-Tuple{AbstractString,AbstractString,InfrastructureSystems.InfrastructureSystemsComponent,Dates.Period}"><code>InfrastructureSystems.SingleTimeSeries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SingleTimeSeries(name::AbstractString, filename::AbstractString, component::InfrastructureSystems.InfrastructureSystemsComponent, resolution::Dates.Period; normalization_factor, scaling_factor_multiplier) -&gt; SingleTimeSeries
</code></pre><p>Construct SingleTimeSeries from a CSV file. The file must have a column that is the name of the component.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>filename::AbstractString</code>: name of CSV file containing data</li><li><code>component::InfrastructureSystemsComponent</code>: component associated with the data</li><li><code>resolution::Dates.Period</code>: resolution of the time series</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.SingleTimeSeries-Tuple{AbstractString,Union{DataFrames.DataFrame, TimeSeries.TimeArray}}" href="#InfrastructureSystems.SingleTimeSeries-Tuple{AbstractString,Union{DataFrames.DataFrame, TimeSeries.TimeArray}}"><code>InfrastructureSystems.SingleTimeSeries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SingleTimeSeries(name::AbstractString, data::Union{DataFrames.DataFrame, TimeSeries.TimeArray}; normalization_factor, scaling_factor_multiplier, timestamp) -&gt; SingleTimeSeries
</code></pre><p>Construct SingleTimeSeries from a TimeArray or DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>data::Union{TimeSeries.TimeArray, DataFrames.DataFrame}</code>: time series data</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li><li><code>timestamp = :timestamp</code>: If a DataFrame is passed then this must be the column name that contains timestamps.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.SingleTimeSeries-Tuple{SingleTimeSeries,TimeSeries.TimeArray}" href="#InfrastructureSystems.SingleTimeSeries-Tuple{SingleTimeSeries,TimeSeries.TimeArray}"><code>InfrastructureSystems.SingleTimeSeries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SingleTimeSeries(time_series::SingleTimeSeries, data::TimeSeries.TimeArray) -&gt; Any
</code></pre><p>Creates a new SingleTimeSeries from an existing instance and a subset of data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.SingleTimeSeries-Tuple{String,Dates.Period,Dates.DateTime,Int64}" href="#InfrastructureSystems.SingleTimeSeries-Tuple{String,Dates.Period,Dates.DateTime,Int64}"><code>InfrastructureSystems.SingleTimeSeries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SingleTimeSeries(name::String, resolution::Dates.Period, initial_time::Dates.DateTime, time_steps::Int64) -&gt; SingleTimeSeries
</code></pre><p>Construct SingleTimeSeries after constructing a TimeArray from <code>initial_time</code> and <code>time_steps</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.from-Tuple{SingleTimeSeries,Any}" href="#InfrastructureSystems.from-Tuple{SingleTimeSeries,Any}"><code>InfrastructureSystems.from</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">from(time_series::SingleTimeSeries, timestamp::Any) -&gt; SingleTimeSeries
</code></pre><p>Return a time_series truncated starting with timestamp.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_count-Tuple{DeterministicSingleTimeSeries}" href="#InfrastructureSystems.get_count-Tuple{DeterministicSingleTimeSeries}"><code>InfrastructureSystems.get_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_count(value::DeterministicSingleTimeSeries) -&gt; Int64
</code></pre><p>Get <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>count</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_data-Tuple{SingleTimeSeries}" href="#InfrastructureSystems.get_data-Tuple{SingleTimeSeries}"><code>InfrastructureSystems.get_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_data(value::SingleTimeSeries) -&gt; TimeSeries.TimeArray
</code></pre><p>Get <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_horizon-Tuple{DeterministicSingleTimeSeries}" href="#InfrastructureSystems.get_horizon-Tuple{DeterministicSingleTimeSeries}"><code>InfrastructureSystems.get_horizon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_horizon(value::DeterministicSingleTimeSeries) -&gt; Int64
</code></pre><p>Get <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>horizon</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_initial_timestamp-Tuple{DeterministicSingleTimeSeries}" href="#InfrastructureSystems.get_initial_timestamp-Tuple{DeterministicSingleTimeSeries}"><code>InfrastructureSystems.get_initial_timestamp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_initial_timestamp(value::DeterministicSingleTimeSeries) -&gt; Dates.DateTime
</code></pre><p>Get <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>initial_timestamp</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_interval-Tuple{DeterministicSingleTimeSeries}" href="#InfrastructureSystems.get_interval-Tuple{DeterministicSingleTimeSeries}"><code>InfrastructureSystems.get_interval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_interval(value::DeterministicSingleTimeSeries) -&gt; Dates.Period
</code></pre><p>Get <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>interval</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_name-Tuple{SingleTimeSeries}" href="#InfrastructureSystems.get_name-Tuple{SingleTimeSeries}"><code>InfrastructureSystems.get_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_name(value::SingleTimeSeries) -&gt; String
</code></pre><p>Get <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_scaling_factor_multiplier-Tuple{SingleTimeSeries}" href="#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{SingleTimeSeries}"><code>InfrastructureSystems.get_scaling_factor_multiplier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_scaling_factor_multiplier(value::SingleTimeSeries) -&gt; Union{Nothing, Function}
</code></pre><p>Get <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_single_time_series-Tuple{DeterministicSingleTimeSeries}" href="#InfrastructureSystems.get_single_time_series-Tuple{DeterministicSingleTimeSeries}"><code>InfrastructureSystems.get_single_time_series</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_single_time_series(value::DeterministicSingleTimeSeries) -&gt; SingleTimeSeries
</code></pre><p>Get <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>single_time_series</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.head-Tuple{SingleTimeSeries}" href="#InfrastructureSystems.head-Tuple{SingleTimeSeries}"><code>InfrastructureSystems.head</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">head(time_series::SingleTimeSeries) -&gt; Any
</code></pre><p>Return a time_series with only the first num values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_count!-Tuple{DeterministicSingleTimeSeries,Any}" href="#InfrastructureSystems.set_count!-Tuple{DeterministicSingleTimeSeries,Any}"><code>InfrastructureSystems.set_count!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_count!(value::DeterministicSingleTimeSeries, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>count</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_data!-Tuple{SingleTimeSeries,Any}" href="#InfrastructureSystems.set_data!-Tuple{SingleTimeSeries,Any}"><code>InfrastructureSystems.set_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_data!(value::SingleTimeSeries, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_horizon!-Tuple{DeterministicSingleTimeSeries,Any}" href="#InfrastructureSystems.set_horizon!-Tuple{DeterministicSingleTimeSeries,Any}"><code>InfrastructureSystems.set_horizon!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_horizon!(value::DeterministicSingleTimeSeries, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>horizon</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_initial_timestamp!-Tuple{DeterministicSingleTimeSeries,Any}" href="#InfrastructureSystems.set_initial_timestamp!-Tuple{DeterministicSingleTimeSeries,Any}"><code>InfrastructureSystems.set_initial_timestamp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_initial_timestamp!(value::DeterministicSingleTimeSeries, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>initial_timestamp</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_interval!-Tuple{DeterministicSingleTimeSeries,Any}" href="#InfrastructureSystems.set_interval!-Tuple{DeterministicSingleTimeSeries,Any}"><code>InfrastructureSystems.set_interval!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_interval!(value::DeterministicSingleTimeSeries, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>interval</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_name!-Tuple{SingleTimeSeries,Any}" href="#InfrastructureSystems.set_name!-Tuple{SingleTimeSeries,Any}"><code>InfrastructureSystems.set_name!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_name!(value::SingleTimeSeries, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{SingleTimeSeries,Any}" href="#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{SingleTimeSeries,Any}"><code>InfrastructureSystems.set_scaling_factor_multiplier!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_scaling_factor_multiplier!(value::SingleTimeSeries, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_single_time_series!-Tuple{DeterministicSingleTimeSeries,Any}" href="#InfrastructureSystems.set_single_time_series!-Tuple{DeterministicSingleTimeSeries,Any}"><code>InfrastructureSystems.set_single_time_series!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_single_time_series!(value::DeterministicSingleTimeSeries, val::Any) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>single_time_series</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.tail-Tuple{SingleTimeSeries}" href="#InfrastructureSystems.tail-Tuple{SingleTimeSeries}"><code>InfrastructureSystems.tail</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tail(time_series::SingleTimeSeries) -&gt; Any
</code></pre><p>Return a time_series with only the ending num values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.to-Tuple{SingleTimeSeries,Any}" href="#InfrastructureSystems.to-Tuple{SingleTimeSeries,Any}"><code>InfrastructureSystems.to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to(time_series::SingleTimeSeries, timestamp::Any) -&gt; SingleTimeSeries
</code></pre><p>Return a time_series truncated after timestamp.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.when-Tuple{SingleTimeSeries,Function,Integer}" href="#InfrastructureSystems.when-Tuple{SingleTimeSeries,Function,Integer}"><code>InfrastructureSystems.when</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">when(time_series::SingleTimeSeries, period::Function, t::Integer) -&gt; Any
</code></pre><p>Refer to TimeSeries.when(). Underlying data is copied.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_initial_times-Tuple{Forecast}" href="#InfrastructureSystems.get_initial_times-Tuple{Forecast}"><code>InfrastructureSystems.get_initial_times</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_initial_times(f::Forecast) -&gt; DataStructures.SDMKeyIteration
</code></pre><p>Return the initial times in the forecast.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_total_period-Tuple{Forecast}" href="#InfrastructureSystems.get_total_period-Tuple{Forecast}"><code>InfrastructureSystems.get_total_period</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_total_period(f::Forecast) -&gt; Any
</code></pre><p>Return the total period covered by the forecast.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_window-Tuple{Forecast,Int64}" href="#InfrastructureSystems.get_window-Tuple{Forecast,Int64}"><code>InfrastructureSystems.get_window</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_window(forecast::Forecast, index::Int64; len) -&gt; Any
</code></pre><p>Return the forecast window corresponsing to interval index.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.index_to_initial_time-Tuple{Forecast,Int64}" href="#InfrastructureSystems.index_to_initial_time-Tuple{Forecast,Int64}"><code>InfrastructureSystems.index_to_initial_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">index_to_initial_time(forecast::Forecast, index::Int64) -&gt; Any
</code></pre><p>Return the Dates.DateTime corresponding to an interval index.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.make_time_array-Tuple{Forecast,Dates.DateTime}" href="#InfrastructureSystems.make_time_array-Tuple{Forecast,Dates.DateTime}"><code>InfrastructureSystems.make_time_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">make_time_array(forecast::Forecast, start_time::Dates.DateTime; len) -&gt; Any
</code></pre><p>Return a TimeSeries.TimeArray for one forecast window.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_next_time-Tuple{InfrastructureSystems.TimeSeriesCache}" href="#InfrastructureSystems.get_next_time-Tuple{InfrastructureSystems.TimeSeriesCache}"><code>InfrastructureSystems.get_next_time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_next_time(cache::InfrastructureSystems.TimeSeriesCache) -&gt; Any
</code></pre><p>Return the timestamp for the next read with <a href="#InfrastructureSystems.get_next_time_series_array!-Tuple{InfrastructureSystems.TimeSeriesCache}"><code>get_next_time_series_array!</code></a>.</p><p>Return <code>nothing</code> if all data has been read.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_next_time_series_array!-Tuple{InfrastructureSystems.TimeSeriesCache}" href="#InfrastructureSystems.get_next_time_series_array!-Tuple{InfrastructureSystems.TimeSeriesCache}"><code>InfrastructureSystems.get_next_time_series_array!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_next_time_series_array!(cache::InfrastructureSystems.TimeSeriesCache) -&gt; Any
</code></pre><p>Return the next TimeSeries.TimeArray.</p><p>Returns <code>nothing</code> when all data has been read. Call <a href="api/@ref"><code>reset!</code></a> to restart. Call <a href="#InfrastructureSystems.get_next_time-Tuple{InfrastructureSystems.TimeSeriesCache}"><code>get_next_time</code></a> to check the start time.</p><p><strong>Arguments</strong></p><ul><li><code>cache::StaticTimeSeriesCache</code>: cached instance</li></ul><p>Reads from storage if the data is not already in cache.</p></div></section></article><h2 id="System"><a class="docs-heading-anchor" href="#System">System</a><a id="System-1"></a><a class="docs-heading-anchor-permalink" href="#System" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System" href="#PowerSystems.System"><code>PowerSystems.System</code></a> — <span class="docstring-category">Type</span></header><section><div><p>System</p><p>A power system defined by fields for base_power, components, and time series.</p><pre><code class="language-julia">System(base_power)
System(base_power, buses, components...)
System(base_power, buses, generators, loads, branches, storage, services; kwargs...)
System(base_power, buses, generators, loads; kwargs...)
System(file; kwargs...)
System(; buses, generators, loads, branches, storage, base_power, services, kwargs...)
System(; kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>base_power::Float64</code>: the base power value for the system</li><li><code>buses::Vector{Bus}</code>: an array of buses</li><li><code>components...</code>: Each element must be an iterable containing subtypes of Component.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>ext::Dict</code>: Contains user-defined parameters. Should only contain standard types.</li><li><code>runchecks::Bool</code>: Run available checks on input fields and when add_component! is called. Throws InvalidRange if an error is found.</li><li><code>time_series_in_memory::Bool=false</code>: Store time series data in memory instead of HDF5.</li><li><code>config_path::String</code>: specify path to validation config file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{AbstractString,AbstractString}" href="#PowerSystems.System-Tuple{AbstractString,AbstractString}"><code>PowerSystems.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System(sys_file::AbstractString, dyr_file::AbstractString; kwargs...) -&gt; Any
</code></pre><p>Parse static and dynamic data directly from PSS/e text files. Automatically generates all the relationships between the available dynamic injection models and the static counterpart</p><p>Each dictionary indexed by id contains a vector with 5 of its components:</p><ul><li>Machine</li><li>Shaft</li><li>AVR</li><li>TurbineGov</li><li>PSS</li></ul><p>Files must be parsed from a .raw file (PTI data format) and a .dyr file.</p><p><strong>Examples:</strong></p><pre><code class="language-julia">raw_file = &quot;Example.raw&quot;
dyr_file = &quot;Example.dyr&quot;
sys = System(raw_file, dyr_file)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{AbstractString}" href="#PowerSystems.System-Tuple{AbstractString}"><code>PowerSystems.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System(file_path::AbstractString; kwargs...) -&gt; Any
</code></pre><p>Constructs a System from a file path ending with .m, .RAW, or .json</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{Any,Any}" href="#PowerSystems.System-Tuple{Any,Any}"><code>PowerSystems.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System(data::Any, base_power::Any; internal, kwargs...) -&gt; System
</code></pre><p>Construct a <code>System</code> from <code>InfrastructureSystems.SystemData</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{Any}" href="#PowerSystems.System-Tuple{Any}"><code>PowerSystems.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System(base_power::Any; kwargs...) -&gt; System
</code></pre><p>Construct an empty <code>System</code>. Useful for building a System while parsing raw data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{Float64,Array{Bus,1},Vararg{Any,N} where N}" href="#PowerSystems.System-Tuple{Float64,Array{Bus,1},Vararg{Any,N} where N}"><code>PowerSystems.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System(base_power::Float64, buses::Array{Bus,1}, components::Vararg{Any,N} where N; kwargs...) -&gt; System
</code></pre><p>System constructor when components are constructed externally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{Nothing}" href="#PowerSystems.System-Tuple{Nothing}"><code>PowerSystems.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System(::Nothing; buses, generators, loads, branches, storage, base_power, services, kwargs...) -&gt; System
</code></pre><p>Constructs a non-functional System for demo purposes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{PowerSystemTableData}" href="#PowerSystems.System-Tuple{PowerSystemTableData}"><code>PowerSystems.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System(data::PowerSystemTableData; time_series_resolution, time_series_in_memory, time_series_directory, runchecks, kwargs...) -&gt; System
</code></pre><p>Construct a System from PowerSystemTableData data.</p><p><strong>Arguments</strong></p><ul><li><code>time_series_resolution::Union{DateTime, Nothing}=nothing</code>: only store time_series that match this resolution.</li><li><code>time_series_in_memory::Bool=false</code>: Store time series data in memory instead of HDF5 file</li><li><code>time_series_directory=nothing</code>: Store time series data in directory instead of tmpfs</li><li><code>runchecks::Bool=true</code>: Validate struct fields.</li></ul><p>Throws DataFormatError if time_series with multiple resolutions are detected.</p><ul><li>A time_series has a different resolution than others.</li><li>A time_series has a different horizon than others.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/parsers/power_system_table_data.jl#L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{PowerModelsData}" href="#PowerSystems.System-Tuple{PowerModelsData}"><code>PowerSystems.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System(pm_data::PowerModelsData; kwargs...) -&gt; Any
</code></pre><p>Constructs a System from PowerModelsData.</p><p><strong>Arguments</strong></p><ul><li><code>pm_data::Union{PowerModelsData, Union{String, IO}}</code>: PowerModels data object or supported</li></ul><p>load flow case (*.m, *.raw)</p><p><strong>Keyword arguments</strong></p><ul><li><code>ext::Dict</code>: Contains user-defined parameters. Should only contain standard types.</li><li><code>runchecks::Bool</code>: Run available checks on input fields and when add_component! is called. Throws InvalidRange if an error is found.</li><li><code>time_series_in_memory::Bool=false</code>: Store time series data in memory instead of HDF5.</li><li><code>config_path::String</code>: specify path to validation config file</li><li><code>pm_data_corrections::Bool=true</code> : Run the PowerModels data corrections (aka :validate in PowerModels)</li><li><code>import_all:Bool=false</code> : Import all fields from PTI files</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">sys = System(
    pm_data, config_path = &quot;ACTIVSg25k_validation.json&quot;,
    bus_name_formatter = x-&gt;string(x[&quot;name&quot;]*&quot;-&quot;*string(x[&quot;index&quot;])),
    load_name_formatter = x-&gt;strip(join(x[&quot;source_id&quot;], &quot;_&quot;))
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/parsers/power_models_data.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_multiple" href="#InfrastructureSystems.get_time_series_multiple"><code>InfrastructureSystems.get_time_series_multiple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_time_series_multiple(sys::System) -&gt; Channel{Any}
get_time_series_multiple(sys::System, filter_func::Any; type, name) -&gt; Channel{Any}
</code></pre><p>Return an iterator of time series in order of initial time.</p><p>Note that passing a filter function can be much slower than the other filtering parameters because it reads time series data from media.</p><p>Call <code>collect</code> on the result to get an array.</p><p><strong>Arguments</strong></p><ul><li><code>data::SystemData</code>: system</li><li><code>filter_func = nothing</code>: Only return time series for which this returns true.</li><li><code>type = nothing</code>: Only return time series with this type.</li><li><code>name = nothing</code>: Only return time series matching this value.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">for time_series in get_time_series_multiple(sys)
    @show time_series
end

ts = collect(get_time_series_multiple(sys; type = SingleTimeSeries))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1046">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.to_json-Tuple{System,AbstractString}" href="#InfrastructureSystems.to_json-Tuple{System,AbstractString}"><code>InfrastructureSystems.to_json</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">to_json(sys::System, filename::AbstractString; force, runchecks)
</code></pre><p>Serializes a system to a JSON string.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>filename::AbstractString</code>: filename to write</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>force::Bool = false</code>: whether to overwrite existing files</li><li><code>check::Bool = false</code>: whether to run system validation checks</li></ul><p>Refer to <a href="#PowerSystems.check_component-Tuple{System,Component}"><code>check_component</code></a> for exceptions thrown if <code>check = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_component!-Tuple{System,DynamicInjection,StaticInjection}" href="#PowerSystems.add_component!-Tuple{System,DynamicInjection,StaticInjection}"><code>PowerSystems.add_component!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_component!(sys::System, dyn_injector::DynamicInjection, static_injector::StaticInjection; kwargs...)
</code></pre><p>Add a dynamic injector to the system.</p><p>Throws ArgumentError if the name does not match the static<em>injector name. Throws ArgumentError if the static</em>injector is not attached to the system.</p><p>All rules for the generic add_component! method also apply.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_component!-Union{Tuple{T}, Tuple{System,T}} where T&lt;:Component" href="#PowerSystems.add_component!-Union{Tuple{T}, Tuple{System,T}} where T&lt;:Component"><code>PowerSystems.add_component!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_component!(sys::System, component::T&lt;:Component; skip_validation, kwargs...)
</code></pre><p>Add a component to the system.</p><p>Throws ArgumentError if the component&#39;s name is already stored for its concrete type. Throws ArgumentError if any Component-specific rule is violated. Throws InvalidRange if any of the component&#39;s field values are outside of defined valid range.</p><p><strong>Examples</strong></p><pre><code class="language-julia">sys = System(100.0)

# Add a single component.
add_component!(sys, bus)

# Add many at once.
buses = [bus1, bus2, bus3]
generators = [gen1, gen2, gen3]
foreach(x -&gt; add_component!(sys, x), Iterators.flatten((buses, generators)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_service!-Tuple{Device,Service,System}" href="#PowerSystems.add_service!-Tuple{Device,Service,System}"><code>PowerSystems.add_service!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_service!(device::Device, service::Service, sys::System)
</code></pre><p>Similar to <a href="#PowerSystems.add_service!-Tuple{Device,Service,System}"><code>add_service!</code></a> but for Service and Device already stored in the system. Performs validation checks on the device and the system</p><p><strong>Arguments</strong></p><ul><li><code>device::Device</code>: Device</li><li><code>service::Service</code>: Service</li><li><code>sys::System</code>: system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_service!-Tuple{System,Service,Any}" href="#PowerSystems.add_service!-Tuple{System,Service,Any}"><code>PowerSystems.add_service!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_service!(sys::System, service::Service, contributing_devices::Any; kwargs...)
</code></pre><p>Similar to <a href="#PowerSystems.add_component!-Tuple{System,DynamicInjection,StaticInjection}"><code>add_component!</code></a> but for services.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>service::Service</code>: service to add</li><li><code>contributing_devices</code>: Must be an iterable of type Device</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_service!-Tuple{System,Service,Device}" href="#PowerSystems.add_service!-Tuple{System,Service,Device}"><code>PowerSystems.add_service!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_service!(sys::System, service::Service, contributing_device::Device; kwargs...)
</code></pre><p>Similar to <a href="#PowerSystems.add_component!-Tuple{System,DynamicInjection,StaticInjection}"><code>add_component!</code></a> but for services.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>service::Service</code>: service to add</li><li><code>contributing_device::Device</code>: Valid Device</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_service!-Tuple{System,StaticReserveGroup,Array{#s84,1} where #s84&lt;:Service}" href="#PowerSystems.add_service!-Tuple{System,StaticReserveGroup,Array{#s84,1} where #s84&lt;:Service}"><code>PowerSystems.add_service!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_service!(sys::System, service::StaticReserveGroup, contributing_services::Array{#s84,1} where #s84&lt;:Service; skip_validation, kwargs...)
</code></pre><p>Similar to <a href="#PowerSystems.add_component!-Tuple{System,DynamicInjection,StaticInjection}"><code>add_component!</code></a> but for StaticReserveGroup.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>service::StaticReserveGroup</code>: service to add</li><li><code>contributing_services</code>: contributing services to the group</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_service!-Tuple{System,StaticReserveGroup}" href="#PowerSystems.add_service!-Tuple{System,StaticReserveGroup}"><code>PowerSystems.add_service!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_service!(sys::System, service::StaticReserveGroup; skip_validation, kwargs...)
</code></pre><p>Similar to <a href="#PowerSystems.add_component!-Tuple{System,DynamicInjection,StaticInjection}"><code>add_component!</code></a> but for StaticReserveGroup.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>service::StaticReserveGroup</code>: service to add</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_time_series!-Tuple{System,AbstractString}" href="#PowerSystems.add_time_series!-Tuple{System,AbstractString}"><code>PowerSystems.add_time_series!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_time_series!(sys::System, metadata_file::AbstractString; resolution)
</code></pre><p>Add time series data from a metadata file or metadata descriptors.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>metadata_file::AbstractString</code>: metadata file for timeseries that includes an array of IS.TimeSeriesFileMetadata instances or a vector.</li><li><code>resolution::DateTime.Period=nothing</code>: skip time series that don&#39;t match this resolution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L541">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_time_series!-Tuple{System,Any,TimeSeriesData}" href="#PowerSystems.add_time_series!-Tuple{System,Any,TimeSeriesData}"><code>PowerSystems.add_time_series!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_time_series!(sys::System, components::Any, time_series::TimeSeriesData)
</code></pre><p>Add the same time series data to multiple components.</p><p>This is significantly more efficent than calling <code>add_time_series!</code> for each component individually with the same data because in this case, only one time series array is stored.</p><p>Throws ArgumentError if a component is not stored in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L931">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_time_series!-Tuple{System,Array{InfrastructureSystems.TimeSeriesFileMetadata,1}}" href="#PowerSystems.add_time_series!-Tuple{System,Array{InfrastructureSystems.TimeSeriesFileMetadata,1}}"><code>PowerSystems.add_time_series!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_time_series!(sys::System, file_metadata::Array{InfrastructureSystems.TimeSeriesFileMetadata,1}; resolution)
</code></pre><p>Add time series data from a metadata file or metadata descriptors.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>timeseries_metadata::Vector{IS.TimeSeriesFileMetadata}</code>: metadata for timeseries</li><li><code>resolution::DateTime.Period=nothing</code>: skip time series that don&#39;t match this resolution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L559">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_time_series!-Tuple{System,Component,TimeSeriesData}" href="#PowerSystems.add_time_series!-Tuple{System,Component,TimeSeriesData}"><code>PowerSystems.add_time_series!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_time_series!(sys::System, component::Component, time_series::TimeSeriesData)
</code></pre><p>Add time series data to a component.</p><p>Throws ArgumentError if the component is not stored in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L921">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.check-Tuple{System}" href="#PowerSystems.check-Tuple{System}"><code>PowerSystems.check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check(sys::System)
</code></pre><p>Check system consistency and validity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.check_component-Tuple{System,Component}" href="#PowerSystems.check_component-Tuple{System,Component}"><code>PowerSystems.check_component</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_component(sys::System, component::Component)
</code></pre><p>Check the values of a component.</p><p>Throws InvalidRange if any of the component&#39;s field values are outside of defined valid range.</p><p>Throws InvalidValue if the custom validate method for the type fails its check.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.check_components-Tuple{System}" href="#PowerSystems.check_components-Tuple{System}"><code>PowerSystems.check_components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_components(sys::System)
</code></pre><p>Check the values of all components. See <a href="#PowerSystems.check_component-Tuple{System,Component}"><code>check_component</code></a> for exceptions thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.clear_components!-Tuple{System}" href="#PowerSystems.clear_components!-Tuple{System}"><code>PowerSystems.clear_components!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear_components!(sys::System)
</code></pre><p>Remove all components from the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.clear_ext!-Tuple{System}" href="#PowerSystems.clear_ext!-Tuple{System}"><code>PowerSystems.clear_ext!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear_ext!(sys::System)
</code></pre><p>Clear any value stored in ext.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.clear_time_series!-Tuple{System}" href="#PowerSystems.clear_time_series!-Tuple{System}"><code>PowerSystems.clear_time_series!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear_time_series!(sys::System)
</code></pre><p>Remove all time series data from the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1078">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.convert_component!-Tuple{Type{Line},MonitoredLine,System}" href="#PowerSystems.convert_component!-Tuple{Type{Line},MonitoredLine,System}"><code>PowerSystems.convert_component!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_component!(linetype::Type{Line}, line::MonitoredLine, sys::System; kwargs...)
</code></pre><p>Converts a MonitoredLine component to a Line component and replaces the original in the system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1661">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.convert_component!-Tuple{Type{MonitoredLine},Line,System}" href="#PowerSystems.convert_component!-Tuple{Type{MonitoredLine},Line,System}"><code>PowerSystems.convert_component!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert_component!(linetype::Type{MonitoredLine}, line::Line, sys::System; kwargs...)
</code></pre><p>Converts a Line component to a MonitoredLine component and replaces the original in the system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1628">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.copy_time_series!-Tuple{Component,Component}" href="#PowerSystems.copy_time_series!-Tuple{Component,Component}"><code>PowerSystems.copy_time_series!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copy_time_series!(dst::Component, src::Component; name_mapping, scaling_factor_multiplier_mapping)
</code></pre><p>Efficiently add all time series data in one component to another by copying the underlying references.</p><p><strong>Arguments</strong></p><ul><li><code>dst::Component</code>: Destination component</li><li><code>src::Component</code>: Source component</li><li><code>name_mapping::Dict = nothing</code>: Optionally map src names to different dst names. If provided and src has a time series with a name not present in name<em>mapping, that time series will not copied. If name</em>mapping is nothing then all time series will be copied with src&#39;s names.</li><li><code>scaling_factor_multiplier_mapping::Dict = nothing</code>: Optionally map src scaling<em>factor</em>multipliers to dst scaling<em>factor</em>multipliers. Same behaviors as name_mapping.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L943">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_aggregation_topology_mapping-Union{Tuple{T}, Tuple{Type{T},System}} where T&lt;:AggregationTopology" href="#PowerSystems.get_aggregation_topology_mapping-Union{Tuple{T}, Tuple{Type{T},System}} where T&lt;:AggregationTopology"><code>PowerSystems.get_aggregation_topology_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_aggregation_topology_mapping(_::Type{T&lt;:AggregationTopology}, sys::System) -&gt; Dict{String,Array{Bus,1}}
</code></pre><p>Return a mapping of AggregationTopology name to vector of buses within it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L878">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_base_power-Tuple{System}" href="#PowerSystems.get_base_power-Tuple{System}"><code>PowerSystems.get_base_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_base_power(sys::System) -&gt; Float64
</code></pre><p>Return the system&#39;s base power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_bus-Tuple{System,Int64}" href="#PowerSystems.get_bus-Tuple{System,Int64}"><code>PowerSystems.get_bus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_bus(sys::System, bus_number::Int64) -&gt; Any
</code></pre><p>Return bus with bus_number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_bus-Tuple{System,String}" href="#PowerSystems.get_bus-Tuple{System,String}"><code>PowerSystems.get_bus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_bus(sys::System, name::String) -&gt; Union{Nothing, Bus}
</code></pre><p>Return bus with name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_bus_numbers-Tuple{System}" href="#PowerSystems.get_bus_numbers-Tuple{System}"><code>PowerSystems.get_bus_numbers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_bus_numbers(sys::System) -&gt; Array{Int64,1}
</code></pre><p>Return a sorted vector of bus numbers in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_buses-Tuple{System,AggregationTopology}" href="#PowerSystems.get_buses-Tuple{System,AggregationTopology}"><code>PowerSystems.get_buses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_buses(sys::System, aggregator::AggregationTopology) -&gt; Array{Bus,1}
</code></pre><p>Return a vector of buses contained within the AggregationTopology.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L901">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_buses-Tuple{System,Set{Int64}}" href="#PowerSystems.get_buses-Tuple{System,Set{Int64}}"><code>PowerSystems.get_buses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_buses(sys::System, bus_numbers::Set{Int64}) -&gt; Array{Bus,1}
</code></pre><p>Return all buses values with bus_numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_component-Union{Tuple{T}, Tuple{Type{T},System,AbstractString}} where T&lt;:Component" href="#PowerSystems.get_component-Union{Tuple{T}, Tuple{Type{T},System,AbstractString}} where T&lt;:Component"><code>PowerSystems.get_component</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the component of type T with name. Returns nothing if no component matches. If T is an abstract type then the names of components across all subtypes of T must be unique.</p><p>See <a href="#PowerSystems.get_components_by_name-Union{Tuple{T}, Tuple{Type{T},System,AbstractString}} where T&lt;:Component"><code>get_components_by_name</code></a> for abstract types with non-unique names across subtypes.</p><p>Throws ArgumentError if T is not a concrete type and there is more than one component with     requested name</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_components-Union{Tuple{T}, Tuple{Type{T},System}} where T&lt;:Component" href="#PowerSystems.get_components-Union{Tuple{T}, Tuple{Type{T},System}} where T&lt;:Component"><code>PowerSystems.get_components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_components(_::Type{T&lt;:Component}, sys::System) -&gt; InfrastructureSystems.FlattenIteratorWrapper{_A} where _A
</code></pre><p>Returns an iterator of components. T can be concrete or abstract. Call collect on the result if an array is desired.</p><p><strong>Examples</strong></p><pre><code class="language-julia">iter = PowerSystems.get_components(ThermalStandard, sys)
iter = PowerSystems.get_components(Generator, sys)
iter = PowerSystems.get_components(Generator, sys, x-&gt;(PowerSystems.get_available(x)))
generators = collect(PowerSystems.get_components(Generator, sys))</code></pre><p>See also: <a href="#PowerSystems.iterate_components-Tuple{System}"><code>iterate_components</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_components_by_name-Union{Tuple{T}, Tuple{Type{T},System,AbstractString}} where T&lt;:Component" href="#PowerSystems.get_components_by_name-Union{Tuple{T}, Tuple{Type{T},System,AbstractString}} where T&lt;:Component"><code>PowerSystems.get_components_by_name</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the components of abstract type T with name. Note that PowerSystems enforces unique names on each concrete type but not across concrete types.</p><p>See <a href="#PowerSystems.get_component-Union{Tuple{T}, Tuple{Type{T},System,AbstractString}} where T&lt;:Component"><code>get_component</code></a> if the concrete type is known.</p><p>Throws ArgumentError if T is not an abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L766">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_components_in_aggregation_topology-Union{Tuple{T}, Tuple{Type{T},System,AggregationTopology}} where T&lt;:StaticInjection" href="#PowerSystems.get_components_in_aggregation_topology-Union{Tuple{T}, Tuple{Type{T},System,AggregationTopology}} where T&lt;:StaticInjection"><code>PowerSystems.get_components_in_aggregation_topology</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_components_in_aggregation_topology(_::Type{T&lt;:StaticInjection}, sys::System, aggregator::AggregationTopology) -&gt; Array{_A,1} where _A
</code></pre><p>Return a vector of components with buses in the AggregationTopology.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_contributing_device_mapping-Tuple{System}" href="#PowerSystems.get_contributing_device_mapping-Tuple{System}"><code>PowerSystems.get_contributing_device_mapping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_contributing_device_mapping(sys::System) -&gt; Dict{NamedTuple{(:type, :name),Tuple{DataType,String}},ServiceContributingDevices}
</code></pre><p>Return an instance of ServiceContributingDevicesMapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L844">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_contributing_devices-Union{Tuple{T}, Tuple{System,T}} where T&lt;:Service" href="#PowerSystems.get_contributing_devices-Union{Tuple{T}, Tuple{System,T}} where T&lt;:Service"><code>PowerSystems.get_contributing_devices</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a vector of devices contributing to the service.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_ext-Tuple{System}" href="#PowerSystems.get_ext-Tuple{System}"><code>PowerSystems.get_ext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_ext(sys::System) -&gt; Union{Nothing, Dict{String,Any}}
</code></pre><p>Return a user-modifiable dictionary to store extra information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_forecast_horizon-Tuple{System}" href="#PowerSystems.get_forecast_horizon-Tuple{System}"><code>PowerSystems.get_forecast_horizon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_forecast_horizon(sys::System) -&gt; Int64
</code></pre><p>Return the horizon for all forecasts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1026">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_forecast_initial_times-Tuple{System}" href="#PowerSystems.get_forecast_initial_times-Tuple{System}"><code>PowerSystems.get_forecast_initial_times</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_forecast_initial_times(sys::System) -&gt; Union{Array{Any,1}, StepRange{Dates.DateTime,_A} where _A}
</code></pre><p>Return the initial times for all forecasts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1011">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_forecast_initial_timestamp-Tuple{System}" href="#PowerSystems.get_forecast_initial_timestamp-Tuple{System}"><code>PowerSystems.get_forecast_initial_timestamp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_forecast_initial_timestamp(sys::System) -&gt; Dates.DateTime
</code></pre><p>Return the initial_timestamp for all forecasts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1031">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_forecast_interval-Tuple{System}" href="#PowerSystems.get_forecast_interval-Tuple{System}"><code>PowerSystems.get_forecast_interval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_forecast_interval(sys::System) -&gt; Dates.Period
</code></pre><p>Return the interval for all forecasts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1036">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_forecast_total_period-Tuple{System}" href="#PowerSystems.get_forecast_total_period-Tuple{System}"><code>PowerSystems.get_forecast_total_period</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_forecast_total_period(sys::System) -&gt; Any
</code></pre><p>Return the total period covered by all forecasts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1016">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_forecast_window_count-Tuple{System}" href="#PowerSystems.get_forecast_window_count-Tuple{System}"><code>PowerSystems.get_forecast_window_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_forecast_window_count(sys::System) -&gt; Int64
</code></pre><p>Return the window count for all forecasts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1021">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_frequency-Tuple{System}" href="#PowerSystems.get_frequency-Tuple{System}"><code>PowerSystems.get_frequency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_frequency(sys::System) -&gt; Float64
</code></pre><p>Return the system&#39;s frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_runchecks-Tuple{System}" href="#PowerSystems.get_runchecks-Tuple{System}"><code>PowerSystems.get_runchecks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_runchecks(sys::System) -&gt; Bool
</code></pre><p>Return true if checks are enabled on the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_time_series_resolution-Tuple{System}" href="#PowerSystems.get_time_series_resolution-Tuple{System}"><code>PowerSystems.get_time_series_resolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_time_series_resolution(sys::System) -&gt; Dates.Period
</code></pre><p>Return the resolution for all time series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1041">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.iterate_components-Tuple{System}" href="#PowerSystems.iterate_components-Tuple{System}"><code>PowerSystems.iterate_components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">iterate_components(sys::System) -&gt; Channel{Any}
</code></pre><p>Iterates over all components.</p><p><strong>Examples</strong></p><pre><code class="language-julia">for component in iterate_components(sys)
    @show component
end</code></pre><p>See also: <a href="#PowerSystems.get_components-Union{Tuple{T}, Tuple{Type{T},System}} where T&lt;:Component"><code>get_components</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.remove_component!-Union{Tuple{T}, Tuple{System,T}} where T&lt;:Component" href="#PowerSystems.remove_component!-Union{Tuple{T}, Tuple{System,T}} where T&lt;:Component"><code>PowerSystems.remove_component!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Remove a component from the system by its value.</p><p>Throws ArgumentError if the component is not stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L653">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.remove_component!-Union{Tuple{T}, Tuple{Type{T},System,AbstractString}} where T&lt;:Component" href="#PowerSystems.remove_component!-Union{Tuple{T}, Tuple{Type{T},System,AbstractString}} where T&lt;:Component"><code>PowerSystems.remove_component!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Remove a component from the system by its name.</p><p>Throws ArgumentError if the component is not stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.remove_components!-Union{Tuple{T}, Tuple{Type{T},System}} where T&lt;:Component" href="#PowerSystems.remove_components!-Union{Tuple{T}, Tuple{Type{T},System}} where T&lt;:Component"><code>PowerSystems.remove_components!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Remove all components of type T from the system.</p><p>Throws ArgumentError if the type is not stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.remove_time_series!-Union{Tuple{T}, Tuple{System,Type{T},Component,String}} where T&lt;:TimeSeriesData" href="#PowerSystems.remove_time_series!-Union{Tuple{T}, Tuple{System,Type{T},Component,String}} where T&lt;:TimeSeriesData"><code>PowerSystems.remove_time_series!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">remove_time_series!(sys::System, _::Type{T&lt;:TimeSeriesData}, component::Component, name::String)
</code></pre><p>Remove the time series data for a component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1085">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.sanitize_component!-Tuple{Component,System}" href="#PowerSystems.sanitize_component!-Tuple{Component,System}"><code>PowerSystems.sanitize_component!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sanitize_component!(component::Component, sys::System) -&gt; Union{Nothing, NamedTuple{(:min, :max),Tuple{Float64,Float64}}}
</code></pre><p>Sanitize component values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_contributing_services!-Tuple{System,StaticReserveGroup,Array{#s86,1} where #s86&lt;:Service}" href="#PowerSystems.set_contributing_services!-Tuple{System,StaticReserveGroup,Array{#s86,1} where #s86&lt;:Service}"><code>PowerSystems.set_contributing_services!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_contributing_services!(sys::System, service::StaticReserveGroup, val::Array{#s86,1} where #s86&lt;:Service) -&gt; Array{#s86,1} where #s86&lt;:Service
</code></pre><p>Set StaticReserveGroup contributing_services with check</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_runchecks!-Tuple{System,Bool}" href="#PowerSystems.set_runchecks!-Tuple{System,Bool}"><code>PowerSystems.set_runchecks!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_runchecks!(sys::System, value::Bool)
</code></pre><p>Enable or disable system checks. Applies to component addition as well as overall system consistency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_units_base_system!-Tuple{System,String}" href="#PowerSystems.set_units_base_system!-Tuple{System,String}"><code>PowerSystems.set_units_base_system!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_units_base_system!(system::System, settings::String)
</code></pre><p>Sets the units base for the getter functions on the devices. It modifies the behavior of all getter functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.transform_single_time_series!-Tuple{System,Int64,Dates.Period}" href="#PowerSystems.transform_single_time_series!-Tuple{System,Int64,Dates.Period}"><code>PowerSystems.transform_single_time_series!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform_single_time_series!(sys::System, horizon::Int64, interval::Dates.Period)
</code></pre><p>Transform all instances of SingleTimeSeries to DeterministicSingleTimeSeries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1097">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.validate_component-Tuple{Component}" href="#PowerSystems.validate_component-Tuple{Component}"><code>PowerSystems.validate_component</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">validate_component(component::Component) -&gt; Bool
</code></pre><p>Validate the component fields using only those fields. Refer to <a href="#PowerSystems.validate_component_with_system-Tuple{Component,System}"><code>validate_component_with_system</code></a> to use other System data for the validation.</p><p>Return true if the instance is valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.validate_component_with_system-Tuple{Component,System}" href="#PowerSystems.validate_component_with_system-Tuple{Component,System}"><code>PowerSystems.validate_component_with_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">validate_component_with_system(component::Component, sys::System) -&gt; Bool
</code></pre><p>Validate a component against System data. Return true if the instance is valid.</p><p>Refer to <a href="#PowerSystems.validate_component-Tuple{Component}"><code>validate_component</code></a> if the validation logic only requires data contained within the instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/base.jl#L1123">source</a></section></article><h2 id="Additional-Component-Methods"><a class="docs-heading-anchor" href="#Additional-Component-Methods">Additional Component Methods</a><a id="Additional-Component-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Component-Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_max_active_power-Union{Tuple{T}, Tuple{T}} where T&lt;:Device" href="#PowerSystems.get_max_active_power-Union{Tuple{T}, Tuple{T}} where T&lt;:Device"><code>PowerSystems.get_max_active_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_max_active_power(d::T&lt;:Device) -&gt; Any
</code></pre><p>Return the max active power for a device from get<em>active</em>power_limits.max</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/supplemental_accessors.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_max_reactive_power-Tuple{RenewableDispatch}" href="#PowerSystems.get_max_reactive_power-Tuple{RenewableDispatch}"><code>PowerSystems.get_max_reactive_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_max_reactive_power(d::RenewableDispatch) -&gt; Any
</code></pre><p>Return the max reactive power for the Renewable Generation calculated as the rating * power<em>factor if reactive</em>power_limits is nothing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/supplemental_accessors.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_max_reactive_power-Union{Tuple{T}, Tuple{T}} where T&lt;:Device" href="#PowerSystems.get_max_reactive_power-Union{Tuple{T}, Tuple{T}} where T&lt;:Device"><code>PowerSystems.get_max_reactive_power</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the max reactive power for a device from get<em>reactive</em>power_limits.max</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/models/supplemental_accessors.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T&lt;:TimeSeriesData" href="#InfrastructureSystems.get_time_series-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T&lt;:TimeSeriesData"><code>InfrastructureSystems.get_time_series</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_time_series(::Type{T&lt;:TimeSeriesData}, component::InfrastructureSystems.InfrastructureSystemsComponent, name::AbstractString; start_time, len, count) -&gt; Any
</code></pre><p>Return a time series corresponding to the given parameters.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Concrete subtype of TimeSeriesData to return</li><li><code>component::InfrastructureSystemsComponent</code>: Component containing the time series</li><li><code>name::AbstractString</code>: name of time series</li><li><code>start_time::Union{Nothing, Dates.DateTime} = nothing</code>: If nothing, use the <code>initial_timestamp</code> of the time series. If T is a subtype of Forecast then <code>start_time</code> must be the first timstamp of a window.</li><li><code>len::Union{Nothing, Int} = nothing</code>: Length in the time dimension. If nothing, use the entire length.</li><li><code>count::Union{Nothing, Int} = nothing</code>: Only applicable to subtypes of Forecast. Number of forecast windows starting at <code>start_time</code> to return. Defaults to all available.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_array" href="#InfrastructureSystems.get_time_series_array"><code>InfrastructureSystems.get_time_series_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_time_series_array(component::InfrastructureSystems.InfrastructureSystemsComponent, time_series::StaticTimeSeries) -&gt; Any
get_time_series_array(component::InfrastructureSystems.InfrastructureSystemsComponent, time_series::StaticTimeSeries, start_time::Union{Nothing, Dates.DateTime}; len, ignore_scaling_factors) -&gt; Any
</code></pre><p>Return a TimeSeries.TimeArray from a cached StaticTimeSeries instance.</p><p>If the data are scaling factors then the stored scaling<em>factor</em>multiplier will be called on the component and applied to the data unless ignore<em>scaling</em>factors is true.</p><p>See also <a href="api/@ref"><code>StaticTimeSeriesCache</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_array-Tuple{InfrastructureSystems.InfrastructureSystemsComponent,Forecast,Dates.DateTime}" href="#InfrastructureSystems.get_time_series_array-Tuple{InfrastructureSystems.InfrastructureSystemsComponent,Forecast,Dates.DateTime}"><code>InfrastructureSystems.get_time_series_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_time_series_array(component::InfrastructureSystems.InfrastructureSystemsComponent, forecast::Forecast, start_time::Dates.DateTime; len, ignore_scaling_factors) -&gt; Any
</code></pre><p>Return a TimeSeries.TimeArray for one forecast window from a cached Forecast instance.</p><p>If the data are scaling factors then the stored scaling<em>factor</em>multiplier will be called on the component and applied to the data unless ignore<em>scaling</em>factors is true.</p><p>See also <a href="api/@ref"><code>ForecastCache</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_array-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T&lt;:TimeSeriesData" href="#InfrastructureSystems.get_time_series_array-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T&lt;:TimeSeriesData"><code>InfrastructureSystems.get_time_series_array</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a TimeSeries.TimeArray from storage for the given time series parameters.</p><p>If the data are scaling factors then the stored scaling<em>factor</em>multiplier will be called on the component and applied to the data unless ignore<em>scaling</em>factors is true.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_timestamps" href="#InfrastructureSystems.get_time_series_timestamps"><code>InfrastructureSystems.get_time_series_timestamps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_time_series_timestamps(component::InfrastructureSystems.InfrastructureSystemsComponent, forecast::Forecast)
get_time_series_timestamps(component::InfrastructureSystems.InfrastructureSystemsComponent, forecast::Forecast, start_time::Union{Nothing, Dates.DateTime}; len) -&gt; Array{D,1} where D&lt;:Dates.TimeType
</code></pre><p>Return a vector of timestamps from a cached Forecast instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_timestamps" href="#InfrastructureSystems.get_time_series_timestamps"><code>InfrastructureSystems.get_time_series_timestamps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_time_series_timestamps(component::InfrastructureSystems.InfrastructureSystemsComponent, time_series::StaticTimeSeries) -&gt; Array{D,1} where D&lt;:Dates.TimeType
get_time_series_timestamps(component::InfrastructureSystems.InfrastructureSystemsComponent, time_series::StaticTimeSeries, start_time::Union{Nothing, Dates.DateTime}; len) -&gt; Array{D,1} where D&lt;:Dates.TimeType
</code></pre><p>Return a vector of timestamps from a cached StaticTimeSeries instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_timestamps-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T&lt;:TimeSeriesData" href="#InfrastructureSystems.get_time_series_timestamps-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T&lt;:TimeSeriesData"><code>InfrastructureSystems.get_time_series_timestamps</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a vector of timestamps from storage for the given time series parameters.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_values" href="#InfrastructureSystems.get_time_series_values"><code>InfrastructureSystems.get_time_series_values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_time_series_values(component::InfrastructureSystems.InfrastructureSystemsComponent, time_series::StaticTimeSeries) -&gt; Any
get_time_series_values(component::InfrastructureSystems.InfrastructureSystemsComponent, time_series::StaticTimeSeries, start_time::Union{Nothing, Dates.DateTime}; len, ignore_scaling_factors) -&gt; Any
</code></pre><p>Return an Array of values from a cached StaticTimeSeries instance for the requested time series parameters.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_values-Tuple{InfrastructureSystems.InfrastructureSystemsComponent,Forecast,Dates.DateTime}" href="#InfrastructureSystems.get_time_series_values-Tuple{InfrastructureSystems.InfrastructureSystemsComponent,Forecast,Dates.DateTime}"><code>InfrastructureSystems.get_time_series_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_time_series_values(component::InfrastructureSystems.InfrastructureSystemsComponent, forecast::Forecast, start_time::Dates.DateTime; len, ignore_scaling_factors) -&gt; Any
</code></pre><p>Return an Array of values for one forecast window from a cached Forecast instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_values-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T&lt;:TimeSeriesData" href="#InfrastructureSystems.get_time_series_values-Union{Tuple{T}, Tuple{Type{T},InfrastructureSystems.InfrastructureSystemsComponent,AbstractString}} where T&lt;:TimeSeriesData"><code>InfrastructureSystems.get_time_series_values</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return an Array of values from storage for the requested time series parameters.</p><p>If the data size is small and this will be called many times, consider using the version that accepts a cached TimeSeriesData instance.</p></div></section></article><h2 id="net_mat"><a class="docs-heading-anchor" href="#net_mat">Network Matrices</a><a id="net_mat-1"></a><a class="docs-heading-anchor-permalink" href="#net_mat" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Ybus" href="#PowerSystems.Ybus"><code>PowerSystems.Ybus</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Nodal admittance matrix (Ybus) is an N x N matrix describing a power system with N buses. It represents the nodal admittance of the buses in a power system.</p><p>The Ybus Struct is indexed using the Bus Numbers, no need for them to be sequential</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/network_calculations/ybus_calculations.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Ybus" href="#PowerSystems.Ybus"><code>PowerSystems.Ybus</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Builds a Ybus from a collection of buses and branches. The return is a Ybus Array indexed with the bus numbers and the branch names.</p><p><strong>Keyword arguments</strong></p><ul><li><code>check_connectivity::Bool</code>: Checks connectivity of the network using Goderya&#39;s algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/network_calculations/ybus_calculations.jl#L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Ybus-Tuple{System}" href="#PowerSystems.Ybus-Tuple{System}"><code>PowerSystems.Ybus</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Builds a Ybus from the system. The return is a Ybus Array indexed with the bus numbers and the branch names.</p><p><strong>Keyword arguments</strong></p><ul><li><code>check_connectivity::Bool</code>: Checks connectivity of the network using Goderya&#39;s algorithm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/network_calculations/ybus_calculations.jl#L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PTDF" href="#PowerSystems.PTDF"><code>PowerSystems.PTDF</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Power Transfer Distribution Factors (PTDF) indicate the incremental change in real power that occurs on transmission lines due to real power injections changes at the buses.</p><p>The PTDF struct is indexed using the Bus numbers and branch names</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/network_calculations/ptdf_calculations.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PTDF" href="#PowerSystems.PTDF"><code>PowerSystems.PTDF</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Builds the PTDF matrix from a system. The return is a PTDF array indexed with the bus numbers.</p><p><strong>Keyword arguments</strong></p><ul><li><code>dist_slack::Vector{Float64}</code>: Vector of weights to be used as distributed slack bus.   The distributed slack vector has to be the same length as the number of buses</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/network_calculations/ptdf_calculations.jl#L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PTDF" href="#PowerSystems.PTDF"><code>PowerSystems.PTDF</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Builds the PTDF matrix from a group of branches and nodes. The return is a PTDF array indexed with the bus numbers.</p><p><strong>Keyword arguments</strong></p><ul><li><code>dist_slack::Vector{Float64}</code>: Vector of weights to be used as distributed slack bus.   The distributed slack vector has to be the same length as the number of buses</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/network_calculations/ptdf_calculations.jl#L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.LODF" href="#PowerSystems.LODF"><code>PowerSystems.LODF</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Line Outage Distribution Factors (LODFs) are a sensitivity measure of how a change in a line’s flow affects the flows on other lines in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/network_calculations/lodf_calculations.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.LODF" href="#PowerSystems.LODF"><code>PowerSystems.LODF</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Builds the LODF matrix from a system. The return is a LOLDF array indexed with the branch name.</p><p><strong>Keyword arguments</strong></p><ul><li><code>dist_slack::Vector{Float64}</code>: Vector of weights to be used as distributed slack bus.   The distributed slack vector has to be the same length as the number of buses</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/network_calculations/lodf_calculations.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.LODF" href="#PowerSystems.LODF"><code>PowerSystems.LODF</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Builds the LODF matrix from a group of branches and nodes. The return is a LOLDF array indexed with the branch name.</p><p><strong>Keyword arguments</strong></p><ul><li><code>dist_slack::Vector{Float64}</code>: Vector of weights to be used as distributed slack bus.   The distributed slack vector has to be the same length as the number of buses</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/network_calculations/lodf_calculations.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_data-Tuple{PowerSystems.PowerNetworkMatrix}" href="#InfrastructureSystems.get_data-Tuple{PowerSystems.PowerNetworkMatrix}"><code>InfrastructureSystems.get_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_data(mat::PowerSystems.PowerNetworkMatrix) -&gt; Any
</code></pre><p>returns the raw array data of the <code>PowerNetworkMatrix</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/network_calculations/common.jl#L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_lookup-Tuple{PowerSystems.PowerNetworkMatrix}" href="#PowerSystems.get_lookup-Tuple{PowerSystems.PowerNetworkMatrix}"><code>PowerSystems.get_lookup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_lookup(mat::PowerSystems.PowerNetworkMatrix) -&gt; Any
</code></pre><pre><code class="language-none">returns the lookup tuple of the `PowerNetworkMatrix`. The first entry corresponds
to the first dimension and the second entry corresponds to the second dimension. For
instance in Ybus the first dimension is buses and second dimension is buses too, and in
PTDF the first dimension is branches and the second dimension is buses</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/network_calculations/common.jl#L245">source</a></section></article><h2 id="pf"><a class="docs-heading-anchor" href="#pf">Power Flow</a><a id="pf-1"></a><a class="docs-heading-anchor-permalink" href="#pf" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.solve_powerflow!-Tuple{System}" href="#PowerSystems.solve_powerflow!-Tuple{System}"><code>PowerSystems.solve_powerflow!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve_powerflow!(system::System; finite_diff, kwargs...) -&gt; Bool
</code></pre><p>Solves a the power flow into the system and writes the solution into the relevant structs. Updates generators active and reactive power setpoints and branches active and reactive power flows (calculated in the From - To direction) (see <a href="../internal/#PowerSystems.flow_val-Tuple{ACBranch}"><code>flow_val</code></a>)</p><p>Supports solving using Finite Differences Method (instead of using analytic Jacobian) by setting finite_diff = true. Supports passing NLsolve kwargs in the args. By default shows the solver trace.</p><p>Arguments available for <code>nlsolve</code>:</p><ul><li><code>method</code> : See NLSolve.jl documentation for available solvers</li><li><code>xtol</code>: norm difference in <code>x</code> between two successive iterates under which convergence is declared. Default: <code>0.0</code>.</li><li><code>ftol</code>: infinite norm of residuals under which convergence is declared. Default: <code>1e-8</code>.</li><li><code>iterations</code>: maximum number of iterations. Default: <code>1_000</code>.</li><li><code>store_trace</code>: should a trace of the optimization algorithm&#39;s state be stored? Default: <code>false</code>.</li><li><code>show_trace</code>: should a trace of the optimization algorithm&#39;s state be shown on <code>STDOUT</code>? Default: <code>false</code>.</li><li><code>extended_trace</code>: should additifonal algorithm internals be added to the state trace? Default: <code>false</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">solve_powerflow!(sys)
# Passing NLsolve arguments
solve_powerflow!(sys, method = :newton)
# Using Finite Differences
solve_powerflow!(sys, finite_diff = true)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/power_flow.jl#L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.solve_powerflow-Tuple{System}" href="#PowerSystems.solve_powerflow-Tuple{System}"><code>PowerSystems.solve_powerflow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve_powerflow(system::System; finite_diff, kwargs...) -&gt; Union{Bool, Dict{String,DataFrames.DataFrame}}
</code></pre><p>Similar to solve_powerflow!(sys) but does not update the system struct with results. Returns the results in a dictionary of dataframes.</p><p><strong>Examples</strong></p><pre><code class="language-julia">res = solve_powerflow(sys)
# Passing NLsolve arguments
res = solve_powerflow(sys, method = :newton)
# Using Finite Differences
res = solve_powerflow(sys, finite_diff = true)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/power_flow.jl#L317">source</a></section></article><h2 id="Parsing"><a class="docs-heading-anchor" href="#Parsing">Parsing</a><a id="Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PowerSystemTableData-Tuple{AbstractString,Float64,AbstractString}" href="#PowerSystems.PowerSystemTableData-Tuple{AbstractString,Float64,AbstractString}"><code>PowerSystems.PowerSystemTableData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PowerSystemTableData(directory::AbstractString, base_power::Float64, user_descriptor_file::AbstractString; descriptor_file, generator_mapping_file, timeseries_metadata_file) -&gt; PowerSystemTableData
</code></pre><p>Reads in all the data stored in csv files The general format for data is     folder:         gen.csv         branch.csv         bus.csv         ..         load.csv</p><p><strong>Arguments</strong></p><ul><li><code>directory::AbstractString</code>: directory containing CSV files</li><li><code>base_power::Float64</code>: base power for System</li><li><code>user_descriptor_file::AbstractString</code>: customized input descriptor file</li><li><code>descriptor_file=POWER_SYSTEM_DESCRIPTOR_FILE</code>: PowerSystems descriptor file</li><li><code>generator_mapping_file=GENERATOR_MAPPING_FILE</code>: generator mapping configuration file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/parsers/power_system_table_data.jl#L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PowerModelsData" href="#PowerSystems.PowerModelsData"><code>PowerSystems.PowerModelsData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Container for data parsed by PowerModels</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/parsers/power_models_data.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PowerModelsData-Tuple{Union{IO, String}}" href="#PowerSystems.PowerModelsData-Tuple{Union{IO, String}}"><code>PowerSystems.PowerModelsData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PowerModelsData(file::Union{IO, String}; kwargs...) -&gt; PowerModelsData
</code></pre><p>Constructs PowerModelsData from a raw file. Currently Supports MATPOWER and PSSE data files parsed by PowerModels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/parsers/power_models_data.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.TamuSystem-Tuple{AbstractString}" href="#PowerSystems.TamuSystem-Tuple{AbstractString}"><code>PowerSystems.TamuSystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TamuSystem(tamu_folder::AbstractString; kwargs...) -&gt; Any
</code></pre><p>Creates a system from a PSS/e .RAW (v33) load flow case, and an associated .csv with MW load time series data. The format is established by the <a href="https://electricgrids.engr.tamu.edu/electric-grid-test-cases/">Texas A&amp;M University Test Case Archive</a></p><p>The general format for data is folder:    [casename].raw    [casename]<em>load</em>time<em>series</em>MW.csv</p><p><strong>Arguments</strong></p><ul><li><code>directory::AbstractString</code>: directory containing RAW and CSV files</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">sys = TamuSystem(
    &quot;./ACTIVSg25k&quot;,
    config_path = &quot;ACTIVSg25k_validation.json&quot;,
    bus_name_formatter = x-&gt;string(x[&quot;name&quot;]*&quot;-&quot;*string(x[&quot;index&quot;])),
    load_name_formatter = x-&gt;strip(join(x[&quot;source_id&quot;], &quot;_&quot;))
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/parsers/TAMU_data.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_dyn_injectors!-Tuple{System,AbstractString}" href="#PowerSystems.add_dyn_injectors!-Tuple{System,AbstractString}"><code>PowerSystems.add_dyn_injectors!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_dyn_injectors!(sys::System, dyr_file::AbstractString)
</code></pre><p>Add to a system already created the dynamic components. The system should already be parsed from a .raw file.</p><p><strong>Examples:</strong></p><pre><code class="language-julia">dyr_file = &quot;Example.dyr&quot;
add_dyn_injectors!(sys, dyr_file)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/parsers/psse_dynamic_data.jl#L177">source</a></section></article><h2 id="logging"><a class="docs-heading-anchor" href="#logging">Logging</a><a id="logging-1"></a><a class="docs-heading-anchor-permalink" href="#logging" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.configure_logging-Tuple{}" href="#PowerSystems.configure_logging-Tuple{}"><code>PowerSystems.configure_logging</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">configure_logging(; console_level, file_level, filename) -&gt; MultiLogger
</code></pre><p>Creates console and file loggers.</p><p><strong>Note:</strong> Log messages may not be written to the file until flush() or close() is called on the returned logger.</p><p><strong>Arguments</strong></p><ul><li><code>console_level = Logging.Error</code>: level for console messages</li><li><code>file_level = Logging.Info</code>: level for file messages</li><li><code>filename::Union{Nothing, AbstractString} = &quot;power-systems.log&quot;</code>: log file; pass nothing to disable file logging</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">logger = configure_logging(console_level = Logging.Info)
@info &quot;log message&quot;
close(logger)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-SIIP/PowerSystems.jl/blob/7125bf1df60ef14c74392d27a23c7445cfcc9772/src/utils/logging.jl#L1">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../model_library/generated_TurbineGov/">« TurbineGov</a><a class="docs-footer-nextpage" href="../internal/">Internal API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 8 February 2021 16:40">Monday 8 February 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
