<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API Reference Â· PowerSystems.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PowerSystems.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome Page</a></li><li><a class="tocitem" href="../../quick_start_guide/">Quick Start Guide</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/basics/">Introduction</a></li><li><a class="tocitem" href="../../tutorials/parse_powerflow_cases/">Parsing PowerFlow Data</a></li><li><a class="tocitem" href="../../tutorials/parse_tabular_data/">Parsing Tabular Data</a></li><li><a class="tocitem" href="../../tutorials/add_forecasts/">Add Forecasts</a></li><li><a class="tocitem" href="../../tutorials/serialize_data/">Serialize Data</a></li><li><a class="tocitem" href="../../tutorials/dynamic_data/">Use Dynamic Data</a></li><li><a class="tocitem" href="../../tutorials/powersystembuilder/">PowerSystemCaseBuilder</a></li><li><a class="tocitem" href="../../tutorials/add_cost_curve/">Add an Operating Cost</a></li></ul></li><li><span class="tocitem">Modeler Guide</span><ul><li><a class="tocitem" href="../../modeler_guide/type_structure/">Type Structure</a></li><li><a class="tocitem" href="../../modeler_guide/system/">System</a></li><li><a class="tocitem" href="../../modeler_guide/time_series/">Time Series Data</a></li><li><a class="tocitem" href="../../modeler_guide/enumerated_types/">Enumerated Types</a></li><li><a class="tocitem" href="../../modeler_guide/example_dynamic_data/">Dynamic Devices</a></li><li><a class="tocitem" href="../../modeler_guide/system_dynamic_data/">Creating a System with Dynamic devices</a></li><li><a class="tocitem" href="../../modeler_guide/cost_functions/">Variable Costs</a></li><li><a class="tocitem" href="../../modeler_guide/market_bid_cost/">PowerSystems <code>MarketBidCost</code></a></li><li><a class="tocitem" href="../../modeler_guide/modeling_with_JuMP/">Modeling with JuMP</a></li><li><a class="tocitem" href="../../modeler_guide/parsing/">Parsing Data</a></li><li><a class="tocitem" href="../../modeler_guide/glossary/">Glossary and Acronyms</a></li></ul></li><li><span class="tocitem">Model Developer Guide</span><ul><li><a class="tocitem" href="../../model_developer_guide/extending_parsing/">Extending Parsing</a></li><li><a class="tocitem" href="../../model_developer_guide/adding_custom_types/">Adding Types</a></li><li><a class="tocitem" href="../../model_developer_guide/adding_additional_fields/">Adding Additional Fields</a></li></ul></li><li><span class="tocitem">Code Base Developer Guide</span><ul><li><a class="tocitem" href="../../code_base_developer_guide/developer/">Developer Guide</a></li><li><a class="tocitem" href="../../code_base_developer_guide/adding_new_types/">Adding New Types</a></li><li><a class="tocitem" href="../../code_base_developer_guide/troubleshooting/">Troubleshooting</a></li></ul></li><li><span class="tocitem">Model Library</span><ul><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">DynamicInverterComponent</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/generated_Converter/">Converter</a></li><li><a class="tocitem" href="../../model_library/generated_DCSource/">DCSource</a></li><li><a class="tocitem" href="../../model_library/generated_Filter/">Filter</a></li><li><a class="tocitem" href="../../model_library/generated_FrequencyEstimator/">FrequencyEstimator</a></li><li><a class="tocitem" href="../../model_library/generated_InnerControl/">InnerControl</a></li><li><a class="tocitem" href="../../model_library/generated_OutputCurrentLimiter/">OutputCurrentLimiter</a></li><li><a class="tocitem" href="../../model_library/outer_control/">OuterControl</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">StaticInjection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/generated_FixedAdmittance/">FixedAdmittance</a></li><li><a class="tocitem" href="../../model_library/generated_InterruptiblePowerLoad/">InterruptiblePowerLoad</a></li><li><a class="tocitem" href="../../model_library/generated_ExponentialLoad/">ExponentialLoad</a></li><li><a class="tocitem" href="../../model_library/generated_PowerLoad/">PowerLoad</a></li><li><a class="tocitem" href="../../model_library/generated_StandardLoad/">StandardLoad</a></li><li><a class="tocitem" href="../../model_library/generated_SwitchedAdmittance/">SwitchedAdmittance</a></li><li><a class="tocitem" href="../../model_library/generated_HydroDispatch/">HydroDispatch</a></li><li><a class="tocitem" href="../../model_library/generated_HydroEnergyReservoir/">HydroEnergyReservoir</a></li><li><a class="tocitem" href="../../model_library/generated_HydroPumpedStorage/">HydroPumpedStorage</a></li><li><a class="tocitem" href="../../model_library/generated_RenewableDispatch/">RenewableDispatch</a></li><li><a class="tocitem" href="../../model_library/generated_RenewableNonDispatch/">RenewableNonDispatch</a></li><li><a class="tocitem" href="../../model_library/generated_ThermalMultiStart/">ThermalMultiStart</a></li><li><a class="tocitem" href="../../model_library/generated_ThermalStandard/">ThermalStandard</a></li><li><a class="tocitem" href="../../model_library/generated_InterconnectingConverter/">InterconnectingConverter</a></li><li><a class="tocitem" href="../../model_library/generated_Source/">Source</a></li><li><a class="tocitem" href="../../model_library/generated_EnergyReservoirStorage/">EnergyReservoirStorage</a></li><li><a class="tocitem" href="../../model_library/hybrid_system/">HybridSystem</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Operating Costs</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/thermal_generation_cost/">ThermalGenerationCost</a></li><li><a class="tocitem" href="../../model_library/hydro_generation_cost/">HydroGenerationCost</a></li><li><a class="tocitem" href="../../model_library/renewable_generation_cost/">RenewableGenerationCost</a></li><li><a class="tocitem" href="../../model_library/storage_cost/">StorageCost</a></li><li><a class="tocitem" href="../../model_library/load_cost/">LoadCost</a></li><li><a class="tocitem" href="../../model_library/market_bid_cost/">MarketBidCost</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-4" type="checkbox"/><label class="tocitem" for="menuitem-7-4"><span class="docs-label">Topology</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/generated_Area/">Area</a></li><li><a class="tocitem" href="../../model_library/generated_LoadZone/">LoadZone</a></li><li><a class="tocitem" href="../../model_library/generated_Arc/">Arc</a></li><li><a class="tocitem" href="../../model_library/generated_ACBus/">ACBus</a></li><li><a class="tocitem" href="../../model_library/generated_DCBus/">DCBus</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-5" type="checkbox"/><label class="tocitem" for="menuitem-7-5"><span class="docs-label">Cost Curves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/cost_curves/">Variable Cost Curves</a></li><li><a class="tocitem" href="../../model_library/value_curves/">Value Curves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-6" type="checkbox"/><label class="tocitem" for="menuitem-7-6"><span class="docs-label">DynamicInjection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/dynamic_inverter/">Dynamic Inverter</a></li><li><a class="tocitem" href="../../model_library/dynamic_generator/">Dynamic Generator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-7" type="checkbox"/><label class="tocitem" for="menuitem-7-7"><span class="docs-label">Service</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/generated_AGC/">AGC</a></li><li><a class="tocitem" href="../../model_library/generated_ConstantReserveNonSpinning/">ConstantReserveNonSpinning</a></li><li><a class="tocitem" href="../../model_library/generated_VariableReserveNonSpinning/">VariableReserveNonSpinning</a></li><li><a class="tocitem" href="../../model_library/generated_TransmissionInterface/">TransmissionInterface</a></li><li><a class="tocitem" href="../../model_library/reserves/">Reserves</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-8" type="checkbox"/><label class="tocitem" for="menuitem-7-8"><span class="docs-label">Branch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/generated_Line/">Line</a></li><li><a class="tocitem" href="../../model_library/generated_MonitoredLine/">MonitoredLine</a></li><li><a class="tocitem" href="../../model_library/generated_PhaseShiftingTransformer/">PhaseShiftingTransformer</a></li><li><a class="tocitem" href="../../model_library/generated_TapTransformer/">TapTransformer</a></li><li><a class="tocitem" href="../../model_library/generated_Transformer2W/">Transformer2W</a></li><li><a class="tocitem" href="../../model_library/generated_TwoTerminalHVDCLine/">TwoTerminalHVDCLine</a></li><li><a class="tocitem" href="../../model_library/generated_TwoTerminalVSCDCLine/">TwoTerminalVSCDCLine</a></li><li><a class="tocitem" href="../../model_library/generated_AreaInterchange/">AreaInterchange</a></li><li><a class="tocitem" href="../../model_library/generated_TModelHVDCLine/">TModelHVDCLine</a></li><li><a class="tocitem" href="../../model_library/dynamic_branch/">Dynamic Lines</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-9" type="checkbox"/><label class="tocitem" for="menuitem-7-9"><span class="docs-label">DynamicGeneratorComponent</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../model_library/generated_AVR/">AVR</a></li><li><a class="tocitem" href="../../model_library/generated_Machine/">Machine</a></li><li><a class="tocitem" href="../../model_library/generated_PSS/">PSS</a></li><li><a class="tocitem" href="../../model_library/generated_Shaft/">Shaft</a></li><li><a class="tocitem" href="../../model_library/generated_TurbineGov/">TurbineGov</a></li></ul></li></ul></li><li class="is-active"><a class="tocitem" href>Public API Reference</a><ul class="internal"><li><a class="tocitem" href="#Modeling"><span>Modeling</span></a></li><li><a class="tocitem" href="#TimeSeries"><span>TimeSeries</span></a></li><li><a class="tocitem" href="#System"><span>System</span></a></li><li><a class="tocitem" href="#Additional-Component-Methods"><span>Additional Component Methods</span></a></li><li><a class="tocitem" href="#Parsing"><span>Parsing</span></a></li><li><a class="tocitem" href="#logging"><span>Logging</span></a></li></ul></li><li><a class="tocitem" href="../internal/">Internal API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/main/docs/src/api/public.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API-Reference"><a class="docs-heading-anchor" href="#Public-API-Reference">Public API Reference</a><a id="Public-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API-Reference" title="Permalink"></a></h1><h2 id="Modeling"><a class="docs-heading-anchor" href="#Modeling">Modeling</a><a id="Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PowerSystems" href="#PowerSystems.PowerSystems"><code>PowerSystems.PowerSystems</code></a> â <span class="docstring-category">Module</span></header><section><div><p>Module for constructing self-contained power system objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/PowerSystems.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Component" href="#PowerSystems.Component"><code>PowerSystems.Component</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype for all PowerSystems components. All subtypes must include a InfrastructureSystemsInternal member. Subtypes should call InfrastructureSystemsInternal() by default, but also must provide a constructor that allows existing values to be deserialized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/PowerSystems.jl#L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Device" href="#PowerSystems.Device"><code>PowerSystems.Device</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype for &quot;devices&quot; (bus, line, etc.) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/PowerSystems.jl#L613">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_base_power-Tuple{Component}" href="#PowerSystems.get_base_power-Tuple{Component}"><code>PowerSystems.get_base_power</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_base_power(c::Component) -&gt; Float64
</code></pre><pre><code class="nohighlight hljs">Default behavior of a component. If there is no base_power field, assume is in the system&#39;s base power.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/components.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_dynamic_injector!-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T&lt;:StaticInjection, U&lt;:Union{Nothing, DynamicInjection}}" href="#PowerSystems.set_dynamic_injector!-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T&lt;:StaticInjection, U&lt;:Union{Nothing, DynamicInjection}}"><code>PowerSystems.set_dynamic_injector!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_dynamic_injector!(
    static_injector::StaticInjection,
    dynamic_injector::Union{Nothing, DynamicInjection}
)
</code></pre><p>Any StaticInjection struct that wants to support dynamic injectors must implement this method to set the value.</p><p>The method is only for internal uses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/injection.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.clear_services!-Tuple{Device}" href="#PowerSystems.clear_services!-Tuple{Device}"><code>PowerSystems.clear_services!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clear_services!(device::Device)
</code></pre><p>Remove all services attached to the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/devices.jl#L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.has_service-Tuple{Device, Service}" href="#PowerSystems.has_service-Tuple{Device, Service}"><code>PowerSystems.has_service</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_service(device::Device, service::Service) -&gt; Bool
</code></pre><p>Return true if the service is attached to the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/devices.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.has_service-Union{Tuple{T}, Tuple{Device, Type{T}}} where T&lt;:Service" href="#PowerSystems.has_service-Union{Tuple{T}, Tuple{Device, Type{T}}} where T&lt;:Service"><code>PowerSystems.has_service</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_service(device::Device, _::Type{T&lt;:Service}) -&gt; Bool
</code></pre><p>Return true if a service with type T is attached to the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/devices.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.remove_service!-Tuple{Device, Service}" href="#PowerSystems.remove_service!-Tuple{Device, Service}"><code>PowerSystems.remove_service!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_service!(device::Device, service::Service)
</code></pre><p>Remove a service from a device.</p><p>Throws ArgumentError if the service is not attached to the device.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/devices.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.ControllableLoad" href="#PowerSystems.ControllableLoad"><code>PowerSystems.ControllableLoad</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype for all controllable loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/loads.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.ElectricLoad" href="#PowerSystems.ElectricLoad"><code>PowerSystems.ElectricLoad</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype for all electric loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/loads.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.StaticLoad" href="#PowerSystems.StaticLoad"><code>PowerSystems.StaticLoad</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype for all <a href="../../modeler_guide/glossary/#S">static</a> electric loads</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/loads.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Generator" href="#PowerSystems.Generator"><code>PowerSystems.Generator</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype for all generation technologies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/generation.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.HydroGen" href="#PowerSystems.HydroGen"><code>PowerSystems.HydroGen</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype for all Hydropower generation technologies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/generation.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.RenewableGen" href="#PowerSystems.RenewableGen"><code>PowerSystems.RenewableGen</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype for all renewable generation technologies</p><p>Requires the implementation of <code>get_rating</code>and <code>get_power_factor</code> methods</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/generation.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.ThermalGen" href="#PowerSystems.ThermalGen"><code>PowerSystems.ThermalGen</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype for all Thermal generation technologies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/generation.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_max_active_power-Tuple{T} where T&lt;:RenewableGen" href="#PowerSystems.get_max_active_power-Tuple{T} where T&lt;:RenewableGen"><code>PowerSystems.get_max_active_power</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_max_active_power(d::RenewableGen) -&gt; Any
</code></pre><p>Return the max active power for the Renewable Generation calculated as the <code>rating</code> * <code>power_factor</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/generation.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_max_reactive_power-Tuple{T} where T&lt;:RenewableGen" href="#PowerSystems.get_max_reactive_power-Tuple{T} where T&lt;:RenewableGen"><code>PowerSystems.get_max_reactive_power</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_max_reactive_power(d::RenewableGen) -&gt; Any
</code></pre><p>Return the max reactive power for the Renewable Generation calculated as the <code>rating</code> * sin(acos(<code>power_factor</code>))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/generation.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Reserve" href="#PowerSystems.Reserve"><code>PowerSystems.Reserve</code></a> â <span class="docstring-category">Type</span></header><section><div><p>A reserve product to be able to respond to unexpected disturbances, such as the sudden loss of a transmission line or generator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/reserves.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.ReserveDirection" href="#PowerSystems.ReserveDirection"><code>PowerSystems.ReserveDirection</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Used to specify if a <a href="#PowerSystems.Reserve"><code>Reserve</code></a> is upwards, downwards, or symmetric</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/reserves.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.ReserveDown" href="#PowerSystems.ReserveDown"><code>PowerSystems.ReserveDown</code></a> â <span class="docstring-category">Type</span></header><section><div><p>A downwards reserve to decrease generation or increase load</p><p>Downwards reserves are used when total load falls below its expected level, typically due to forecast errors or contingencies. Not work</p><p>A <a href="#PowerSystems.Reserve"><code>Reserve</code></a> can be specified as a <code>ReserveDown</code> when it is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/reserves.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.ReserveSymmetric" href="#PowerSystems.ReserveSymmetric"><code>PowerSystems.ReserveSymmetric</code></a> â <span class="docstring-category">Type</span></header><section><div><p>A symmetric reserve, procuring the same quantity (MW) of both upwards and downwards reserves</p><p>A symmetric reserve is a special case. <a href="#PowerSystems.ReserveUp"><code>ReserveUp</code></a> and <a href="#PowerSystems.ReserveDown"><code>ReserveDown</code></a> can be used individually to specify different quantities of upwards and downwards reserves, respectively.</p><p>A <a href="#PowerSystems.Reserve"><code>Reserve</code></a> can be specified as a <code>ReserveSymmetric</code> when it is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/reserves.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.ReserveUp" href="#PowerSystems.ReserveUp"><code>PowerSystems.ReserveUp</code></a> â <span class="docstring-category">Type</span></header><section><div><p>An upwards reserve to increase generation or reduce load</p><p>Upwards reserves are used when total load exceeds its expected level, typically due to forecast errors or contingencies.</p><p>A <a href="#PowerSystems.Reserve"><code>Reserve</code></a> can be specified as a <code>ReserveUp</code> when it is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/reserves.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Storage" href="#PowerSystems.Storage"><code>PowerSystems.Storage</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype for energy storage technologies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/storage.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Service" href="#PowerSystems.Service"><code>PowerSystems.Service</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype for all system services</p><p>Services (or ancillary services) include additional requirements and support to ensure reliable electricity service to customers. Common services are reserve products to be able to respond quickly to unexpected disturbances, such as the sudden loss of a transmission line or generator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/services.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.GeometricDistributionForcedOutage" href="#PowerSystems.GeometricDistributionForcedOutage"><code>PowerSystems.GeometricDistributionForcedOutage</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Attribute that contains information regarding forced outages where the transition probabilities are modeled with geometric distributions. The outage probabilities and recovery probabilities can be modeled as time series.</p><p><strong>Arguments</strong></p><ul><li><code>time_to_recovery::Int</code>: Time elapsed to recovery after a failure in Milliseconds.</li><li><code>outage_transition_probability::Float64</code>: Characterizes the probability of failure (1 - p) in the geometric distribution.</li><li><code>internal::InfrastructureSystemsInternal</code>: power system internal reference, do not modify</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/outages.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PlannedOutage" href="#PowerSystems.PlannedOutage"><code>PowerSystems.PlannedOutage</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Attribute that contains information regarding planned outages.</p><p><strong>Arguments</strong></p><ul><li><code>outage_schedule::String</code>: String name of the time series used for the scheduled outages</li><li><code>internal::InfrastructureSystemsInternal</code>: power system internal reference, do not modify</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/outages.jl#L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.TimeSeriesForcedOutage" href="#PowerSystems.TimeSeriesForcedOutage"><code>PowerSystems.TimeSeriesForcedOutage</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Attribute that contains the representation of the status of the component forced outage. The data can be obtained from the simulation of an stochastic process or historical information.</p><p><strong>Arguments</strong></p><ul><li><code>outage_status_scenario::String</code>: String name of the time series used for the forced outage status in the model. 1 is used represent outaged and 0 for available.</li><li><code>internal::InfrastructureSystemsInternal</code>: power system internal reference, do not modify</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/outages.jl#L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_mean_time_to_recovery-Tuple{GeometricDistributionForcedOutage}" href="#PowerSystems.get_mean_time_to_recovery-Tuple{GeometricDistributionForcedOutage}"><code>PowerSystems.get_mean_time_to_recovery</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_mean_time_to_recovery(
    value::GeometricDistributionForcedOutage
) -&gt; Float64
</code></pre><p>Get <a href="#PowerSystems.GeometricDistributionForcedOutage"><code>GeometricDistributionForcedOutage</code></a> <code>time_to_recovery</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/outages.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_outage_schedule-Tuple{PlannedOutage}" href="#PowerSystems.get_outage_schedule-Tuple{PlannedOutage}"><code>PowerSystems.get_outage_schedule</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_outage_schedule(value::PlannedOutage) -&gt; String
</code></pre><p>Get <a href="#PowerSystems.PlannedOutage"><code>PlannedOutage</code></a> <code>outage_schedule</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/outages.jl#L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_outage_transition_probability-Tuple{GeometricDistributionForcedOutage}" href="#PowerSystems.get_outage_transition_probability-Tuple{GeometricDistributionForcedOutage}"><code>PowerSystems.get_outage_transition_probability</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_outage_transition_probability(
    value::GeometricDistributionForcedOutage
) -&gt; Float64
</code></pre><p>Get <a href="#PowerSystems.GeometricDistributionForcedOutage"><code>GeometricDistributionForcedOutage</code></a> <code>outage_transition_probability</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/outages.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.AggregationTopology" href="#PowerSystems.AggregationTopology"><code>PowerSystems.AggregationTopology</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Represents a geographical region of system components.</p><p>All subtypes must implement the method <code>get_aggregation_topology_accessor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/topological_elements.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Bus" href="#PowerSystems.Bus"><code>PowerSystems.Bus</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Abstract type to represent any type of Bus, AC or DC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/topological_elements.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.Topology" href="#PowerSystems.Topology"><code>PowerSystems.Topology</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Abstract type to represent the structure and interconnectedness of the system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/topological_elements.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_aggregation_topology_accessor-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AggregationTopology" href="#PowerSystems.get_aggregation_topology_accessor-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:AggregationTopology"><code>PowerSystems.get_aggregation_topology_accessor</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_aggregation_topology_accessor(
    _::Type{T&lt;:AggregationTopology}
) -&gt; typeof(get_load_zone)
</code></pre><p>Return the method to be called on a ACBus to get its AggregationTopology value for this type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/topological_elements.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.StaticInjection" href="#PowerSystems.StaticInjection"><code>PowerSystems.StaticInjection</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Abstract type for devices that <a href="../../modeler_guide/glossary/#I">inject</a> power or current</p><p>A <a href="../../modeler_guide/glossary/#S">static</a> injection is a steady state injection, such as modeling the output power of a generator held constant over a five-minute period.</p><p>Many <code>StaticInjection</code> models can accept a <a href="#PowerSystems.DynamicInjection"><code>DynamicInjection</code></a> model as an optional add-on for conducting <a href="../../modeler_guide/glossary/#D">dynamic</a> simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/static_models.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.StaticInjectionSubsystem" href="#PowerSystems.StaticInjectionSubsystem"><code>PowerSystems.StaticInjectionSubsystem</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Abstract type for a subsystem that contains multiple instances of StaticInjection</p><p>Subtypes must implement:</p><ul><li>get_subcomponents(subsystem::StaticInjectionSubsystem)</li></ul><p>The subcomponents in subtypes must be attached to the System as masked components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/static_injection_subsystem.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.copy_subcomponent_time_series!-Tuple{StaticInjectionSubsystem, Component}" href="#PowerSystems.copy_subcomponent_time_series!-Tuple{StaticInjectionSubsystem, Component}"><code>PowerSystems.copy_subcomponent_time_series!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy_subcomponent_time_series!(
    subsystem::StaticInjectionSubsystem,
    subcomponent::Component
)
</code></pre><p>Efficiently add all time series data in the subcomponent to the subsystem by copying the underlying references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/static_injection_subsystem.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.DynamicComponent" href="#PowerSystems.DynamicComponent"><code>PowerSystems.DynamicComponent</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Abstract type for all components used to compose a <a href="#PowerSystems.DynamicInjection"><code>DynamicInjection</code></a> device</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/dynamic_models.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.DynamicInjection" href="#PowerSystems.DynamicInjection"><code>PowerSystems.DynamicInjection</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Abstract type for all <a href="../../modeler_guide/example_dynamic_data/#Dynamic-Devices">Dynamic Devices</a></p><p>A <a href="../../modeler_guide/glossary/#D">dynamic</a> <a href="../../modeler_guide/glossary/#I">injection</a> is the continuous time response of a generator, typically modeled with differential equations. </p><p><code>DynamicInjection</code> components can added on to <a href="#PowerSystems.StaticInjection"><code>StaticInjection</code></a> components, which together define all the information needed to model the device in a dynamic simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/dynamic_models.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_dynamic_components-Tuple{T} where T&lt;:DynamicInjection" href="#PowerSystems.get_dynamic_components-Tuple{T} where T&lt;:DynamicInjection"><code>PowerSystems.get_dynamic_components</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_dynamic_components(
    device::DynamicInjection
) -&gt; Base.Generator{I, F} where {I&lt;:(Base.Iterators.Filter{PowerSystems.var&quot;#6#8&quot;, I} where I&lt;:(Base.Iterators.Zip{Is} where Is&lt;:Tuple{Any, Tuple})), F&lt;:(PowerSystems.var&quot;#5#7&quot;{&lt;:DynamicInjection})}
</code></pre><p>Return all the dynamic components of a <a href="#PowerSystems.DynamicInjection"><code>DynamicInjection</code></a> device</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/dynamic_models.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_states_types-Tuple{DynamicComponent}" href="#PowerSystems.get_states_types-Tuple{DynamicComponent}"><code>PowerSystems.get_states_types</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_states_types(d::DynamicComponent) -&gt; Vector{StateTypes}
</code></pre><pre><code class="nohighlight hljs">Default implementation of get_state_types for dynamic components. Assumes all states are
Differential</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/dynamic_models.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.OperationalCost" href="#PowerSystems.OperationalCost"><code>PowerSystems.OperationalCost</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype for operational cost representations</p><p>Current concrete types include:</p><ul><li><a href="../../model_library/thermal_generation_cost/#PowerSystems.ThermalGenerationCost"><code>ThermalGenerationCost</code></a></li><li><a href="../../model_library/hydro_generation_cost/#PowerSystems.HydroGenerationCost"><code>HydroGenerationCost</code></a></li><li><a href="../../model_library/renewable_generation_cost/#PowerSystems.RenewableGenerationCost"><code>RenewableGenerationCost</code></a></li><li><a href="../../model_library/storage_cost/#PowerSystems.StorageCost"><code>StorageCost</code></a></li><li><a href="../../model_library/load_cost/#PowerSystems.LoadCost"><code>LoadCost</code></a></li><li><a href="../../model_library/market_bid_cost/#PowerSystems.MarketBidCost"><code>MarketBidCost</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/operational_cost.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.AverageRateCurve" href="#PowerSystems.AverageRateCurve"><code>PowerSystems.AverageRateCurve</code></a> â <span class="docstring-category">Type</span></header><section><div><p>An average rate curve, relating the production quantity to the average cost rate from the origin: <code>y = f(x)/x</code>. Can be used, for instance, in the representation of a <a href="../../model_library/cost_curves/#PowerSystems.CostCurve"><code>CostCurve</code></a> where <code>x</code> is MW and <code>y</code> is currency/MWh, or in the representation of a <a href="../../model_library/cost_curves/#PowerSystems.FuelCurve"><code>FuelCurve</code></a> where <code>x</code> is MW and <code>y</code> is fuel/MWh. Typically calculated by dividing absolute values of cost rate or fuel input rate by absolute values of electric power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/ValueCurves.jl#L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.IncrementalCurve" href="#PowerSystems.IncrementalCurve"><code>PowerSystems.IncrementalCurve</code></a> â <span class="docstring-category">Type</span></header><section><div><p>An incremental (or &#39;marginal&#39;) curve, relating the production quantity to the derivative of cost: <code>y = f&#39;(x)</code>. Can be used, for instance, in the representation of a <a href="../../model_library/cost_curves/#PowerSystems.CostCurve"><code>CostCurve</code></a> where <code>x</code> is MW and <code>y</code> is currency/MWh, or in the representation of a <a href="../../model_library/cost_curves/#PowerSystems.FuelCurve"><code>FuelCurve</code></a> where <code>x</code> is MW and <code>y</code> is fuel/MWh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/ValueCurves.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.InputOutputCurve" href="#PowerSystems.InputOutputCurve"><code>PowerSystems.InputOutputCurve</code></a> â <span class="docstring-category">Type</span></header><section><div><p>An input-output curve, directly relating the production quantity to the cost: <code>y = f(x)</code>. Can be used, for instance, in the representation of a <a href="../../model_library/cost_curves/#PowerSystems.CostCurve"><code>CostCurve</code></a> where <code>x</code> is MW and <code>y</code> is currency/hr, or in the representation of a <a href="../../model_library/cost_curves/#PowerSystems.FuelCurve"><code>FuelCurve</code></a> where <code>x</code> is MW and <code>y</code> is fuel/hr.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/ValueCurves.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.ValueCurve" href="#PowerSystems.ValueCurve"><code>PowerSystems.ValueCurve</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype that represents a unitless cost curve</p><p>Concrete options are <a href="../../model_library/value_curves/#value_curve_library">listed here.</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/ValueCurves.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.is_convex-Tuple{ValueCurve}" href="#InfrastructureSystems.is_convex-Tuple{ValueCurve}"><code>InfrastructureSystems.is_convex</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_convex(curve::ValueCurve) -&gt; Bool
</code></pre><p>Calculate the convexity of the underlying data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/ValueCurves.jl#L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_function_data-Tuple{ValueCurve}" href="#PowerSystems.get_function_data-Tuple{ValueCurve}"><code>PowerSystems.get_function_data</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_function_data(curve::ValueCurve) -&gt; Any
</code></pre><p>Get the underlying <code>FunctionData</code> representation of this <code>ValueCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/ValueCurves.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_initial_input-Tuple{Union{AverageRateCurve, IncrementalCurve}}" href="#PowerSystems.get_initial_input-Tuple{Union{AverageRateCurve, IncrementalCurve}}"><code>PowerSystems.get_initial_input</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_initial_input(
    curve::Union{AverageRateCurve, IncrementalCurve}
) -&gt; Union{Nothing, Float64}
</code></pre><p>Get the <code>initial_input</code> field of this <code>ValueCurve</code> (not defined for <code>InputOutputCurve</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/ValueCurves.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_input_at_zero-Tuple{ValueCurve}" href="#PowerSystems.get_input_at_zero-Tuple{ValueCurve}"><code>PowerSystems.get_input_at_zero</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_input_at_zero(curve::ValueCurve) -&gt; Any
</code></pre><p>Get the <code>input_at_zero</code> field of this <code>ValueCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/ValueCurves.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.LinearCurve" href="#PowerSystems.LinearCurve"><code>PowerSystems.LinearCurve</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearCurve(proportional_term::Float64)
LinearCurve(proportional_term::Float64, constant_term::Float64)</code></pre><p>A linear input-output curve, representing a constant marginal rate. May have zero no-load cost (i.e., constant average rate) or not.</p><p><strong>Arguments</strong></p><ul><li><code>proportional_term::Float64</code>: marginal rate</li><li><code>constant_term::Float64</code>: optional, cost at zero production, defaults to <code>0.0</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PiecewiseAverageCurve" href="#PowerSystems.PiecewiseAverageCurve"><code>PowerSystems.PiecewiseAverageCurve</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewiseAverageCurve(initial_input::Union{Float64, Nothing}, x_coords::Vector{Float64}, slopes::Vector{Float64})</code></pre><p>A piecewise linear curve specified by average rates between production points. May have nonzero initial value.</p><p><strong>Arguments</strong></p><ul><li><code>initial_input::Union{Float64, Nothing}</code>: cost at minimum production point <code>first(x_coords)</code> (NOT at zero production), defines the start of the curve</li><li><code>x_coords::Vector{Float64}</code>: vector of <code>n</code> production points</li><li><code>slopes::Vector{Float64}</code>: vector of <code>n-1</code> average rates/slopes of the curve segments between the points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PiecewiseIncrementalCurve" href="#PowerSystems.PiecewiseIncrementalCurve"><code>PowerSystems.PiecewiseIncrementalCurve</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewiseIncrementalCurve(initial_input::Union{Float64, Nothing}, x_coords::Vector{Float64}, slopes::Vector{Float64})
PiecewiseIncrementalCurve(input_at_zero::Union{Nothing, Float64}, initial_input::Union{Float64, Nothing}, x_coords::Vector{Float64}, slopes::Vector{Float64})</code></pre><p>A piecewise linear curve specified by marginal rates (slopes) between production points. May have nonzero initial value.</p><p><strong>Arguments</strong></p><ul><li><code>input_at_zero::Union{Nothing, Float64}</code>: (optional, defaults to <code>nothing</code>) cost at zero production, does NOT represent a part of the curve</li><li><code>initial_input::Union{Float64, Nothing}</code>: cost at minimum production point <code>first(x_coords)</code> (NOT at zero production), defines the start of the curve</li><li><code>x_coords::Vector{Float64}</code>: vector of <code>n</code> production points</li><li><code>slopes::Vector{Float64}</code>: vector of <code>n-1</code> marginal rates/slopes of the curve segments between the points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PiecewisePointCurve" href="#PowerSystems.PiecewisePointCurve"><code>PowerSystems.PiecewisePointCurve</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewisePointCurve(points::Vector{Tuple{Float64, Float64}})</code></pre><p>A piecewise linear curve specified by cost values at production points.</p><p><strong>Arguments</strong></p><ul><li><code>points::Vector{Tuple{Float64, Float64}}</code> or similar: vector of <code>(production, cost)</code> pairs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.QuadraticCurve" href="#PowerSystems.QuadraticCurve"><code>PowerSystems.QuadraticCurve</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuadraticCurve(quadratic_term::Float64, proportional_term::Float64, constant_term::Float64)</code></pre><p>A quadratic input-output curve, may have nonzero no-load cost.</p><p><strong>Arguments</strong></p><ul><li><code>quadratic_term::Float64</code>: quadratic term of the curve</li><li><code>proportional_term::Float64</code>: proportional term of the curve</li><li><code>constant_term::Float64</code>: constant term of the curve</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_constant_term-Tuple{LinearCurve}" href="#InfrastructureSystems.get_constant_term-Tuple{LinearCurve}"><code>InfrastructureSystems.get_constant_term</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_constant_term(vc::LinearCurve) -&gt; Float64
</code></pre><p>Get the constant term (i.e., intercept) of the <code>LinearCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_constant_term-Tuple{QuadraticCurve}" href="#InfrastructureSystems.get_constant_term-Tuple{QuadraticCurve}"><code>InfrastructureSystems.get_constant_term</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_constant_term(vc::QuadraticCurve) -&gt; Float64
</code></pre><p>Get the constant term of the <code>QuadraticCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_points-Tuple{PiecewisePointCurve}" href="#InfrastructureSystems.get_points-Tuple{PiecewisePointCurve}"><code>InfrastructureSystems.get_points</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_points(
    vc::PiecewisePointCurve
) -&gt; Vector{@NamedTuple{x::Float64, y::Float64}}
</code></pre><p>Get the points that define the <code>PiecewisePointCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_proportional_term-Tuple{LinearCurve}" href="#InfrastructureSystems.get_proportional_term-Tuple{LinearCurve}"><code>InfrastructureSystems.get_proportional_term</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_proportional_term(vc::LinearCurve) -&gt; Float64
</code></pre><p>Get the proportional term (i.e., slope) of the <code>LinearCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_proportional_term-Tuple{QuadraticCurve}" href="#InfrastructureSystems.get_proportional_term-Tuple{QuadraticCurve}"><code>InfrastructureSystems.get_proportional_term</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_proportional_term(vc::QuadraticCurve) -&gt; Float64
</code></pre><p>Get the proportional (i.e., linear) term of the <code>QuadraticCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_quadratic_term-Tuple{QuadraticCurve}" href="#InfrastructureSystems.get_quadratic_term-Tuple{QuadraticCurve}"><code>InfrastructureSystems.get_quadratic_term</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_quadratic_term(vc::QuadraticCurve) -&gt; Float64
</code></pre><p>Get the quadratic term of the <code>QuadraticCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_slopes-Tuple{PiecewiseIncrementalCurve}" href="#InfrastructureSystems.get_slopes-Tuple{PiecewiseIncrementalCurve}"><code>InfrastructureSystems.get_slopes</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_slopes(vc::PiecewiseIncrementalCurve) -&gt; Vector{Float64}
</code></pre><p>Fetch the slopes that define the <code>PiecewiseIncrementalCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_slopes-Tuple{PiecewisePointCurve}" href="#InfrastructureSystems.get_slopes-Tuple{PiecewisePointCurve}"><code>InfrastructureSystems.get_slopes</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_slopes(vc::PiecewisePointCurve) -&gt; Vector{Float64}
</code></pre><p>Calculate the slopes of the line segments defined by the <code>PiecewisePointCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_x_coords-Tuple{PiecewiseAverageCurve}" href="#InfrastructureSystems.get_x_coords-Tuple{PiecewiseAverageCurve}"><code>InfrastructureSystems.get_x_coords</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_x_coords(vc::PiecewiseAverageCurve) -&gt; Vector{Float64}
</code></pre><p>Get the x-coordinates that define the <code>PiecewiseAverageCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_x_coords-Tuple{PiecewiseIncrementalCurve}" href="#InfrastructureSystems.get_x_coords-Tuple{PiecewiseIncrementalCurve}"><code>InfrastructureSystems.get_x_coords</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_x_coords(
    vc::PiecewiseIncrementalCurve
) -&gt; Vector{Float64}
</code></pre><p>Get the x-coordinates that define the <code>PiecewiseIncrementalCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_x_coords-Tuple{PiecewisePointCurve}" href="#InfrastructureSystems.get_x_coords-Tuple{PiecewisePointCurve}"><code>InfrastructureSystems.get_x_coords</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_x_coords(vc::PiecewisePointCurve) -&gt; Vector{Float64}
</code></pre><p>Get the x-coordinates of the points that define the <code>PiecewisePointCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_y_coords-Tuple{PiecewisePointCurve}" href="#InfrastructureSystems.get_y_coords-Tuple{PiecewisePointCurve}"><code>InfrastructureSystems.get_y_coords</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_y_coords(vc::PiecewisePointCurve) -&gt; Vector{Float64}
</code></pre><p>Get the y-coordinates of the points that define the <code>PiecewisePointCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_average_rates-Tuple{PiecewiseAverageCurve}" href="#PowerSystems.get_average_rates-Tuple{PiecewiseAverageCurve}"><code>PowerSystems.get_average_rates</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_average_rates(
    vc::PiecewiseAverageCurve
) -&gt; Vector{Float64}
</code></pre><p>Get the average rates that define the <code>PiecewiseAverageCurve</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_functions/cost_aliases.jl#L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_fuel_cost-Tuple{StaticInjection}" href="#PowerSystems.get_fuel_cost-Tuple{StaticInjection}"><code>PowerSystems.get_fuel_cost</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_fuel_cost(
    component::StaticInjection;
    start_time,
    len
) -&gt; Union{Float64, TimeSeries.TimeArray}
</code></pre><p>Get the fuel cost of the component&#39;s variable cost, which must be a <code>FuelCurve</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_function_timeseries.jl#L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_no_load_cost-Tuple{StaticInjection, MarketBidCost}" href="#PowerSystems.get_no_load_cost-Tuple{StaticInjection, MarketBidCost}"><code>PowerSystems.get_no_load_cost</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_no_load_cost(
    device::StaticInjection,
    cost::MarketBidCost;
    start_time,
    len
) -&gt; Union{Float64, TimeSeries.TimeArray}
</code></pre><p>Retrieve the no-load cost data for a <code>StaticInjection</code> device with a <code>MarketBidCost</code>. If this field is a time series, the user may specify <code>start_time</code> and <code>len</code> and the function returns a <code>TimeArray</code> of <code>Float64</code>s; if the field is not a time series, the function returns a single <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_function_timeseries.jl#L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_services_bid-Tuple{StaticInjection, MarketBidCost, Service}" href="#PowerSystems.get_services_bid-Tuple{StaticInjection, MarketBidCost, Service}"><code>PowerSystems.get_services_bid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_services_bid(
    device::StaticInjection,
    cost::MarketBidCost,
    service::Service;
    start_time,
    len
) -&gt; TimeSeries.TimeArray
</code></pre><p>Return service bid time series data for a <code>StaticInjection</code> device with a <code>MarketBidCost</code>. The user may specify <code>start_time</code> and <code>len</code> and the function returns a <code>TimeArray</code> of <code>CostCurve</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_function_timeseries.jl#L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_start_up-Tuple{StaticInjection, MarketBidCost}" href="#PowerSystems.get_start_up-Tuple{StaticInjection, MarketBidCost}"><code>PowerSystems.get_start_up</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_start_up(
    device::StaticInjection,
    cost::MarketBidCost;
    start_time,
    len
) -&gt; Union{@NamedTuple{hot::Float64, warm::Float64, cold::Float64}, TimeSeries.TimeArray}
</code></pre><p>Retrieve the no-load cost data for a <code>StaticInjection</code> device with a <code>MarketBidCost</code>. If this field is a time series, the user may specify <code>start_time</code> and <code>len</code> and the function returns a <code>TimeArray</code> of <code>Float64</code>s; if the field is not a time series, the function returns a single <code>Float64</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_function_timeseries.jl#L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_variable_cost-Tuple{ReserveDemandCurve}" href="#PowerSystems.get_variable_cost-Tuple{ReserveDemandCurve}"><code>PowerSystems.get_variable_cost</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_variable_cost(
    service::ReserveDemandCurve;
    start_time,
    len
) -&gt; Union{CostCurve{PiecewiseIncrementalCurve}, TimeSeries.TimeArray}
</code></pre><p>Retrieve the variable cost data for a <code>ReserveDemandCurve</code>. The user may specify <code>start_time</code> and <code>len</code> and the function returns a <code>TimeArray</code> of <code>CostCurve</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_function_timeseries.jl#L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_variable_cost-Tuple{StaticInjection, MarketBidCost}" href="#PowerSystems.get_variable_cost-Tuple{StaticInjection, MarketBidCost}"><code>PowerSystems.get_variable_cost</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_variable_cost(
    device::StaticInjection,
    cost::MarketBidCost;
    start_time,
    len
) -&gt; Union{CostCurve{PiecewiseIncrementalCurve}, TimeSeries.TimeArray}
</code></pre><p>Retrieve the variable cost bid for a <code>StaticInjection</code> device with a <code>MarketBidCost</code>. If this field is a time series, the user may specify <code>start_time</code> and <code>len</code> and the function returns a <code>TimeArray</code> of <code>CostCurve</code>s; if the field is not a time series, the function returns a single <code>CostCurve</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_function_timeseries.jl#L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_fuel_cost!-Tuple{System, StaticInjection, Union{Float64, TimeSeriesData}}" href="#PowerSystems.set_fuel_cost!-Tuple{System, StaticInjection, Union{Float64, TimeSeriesData}}"><code>PowerSystems.set_fuel_cost!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_fuel_cost!(
    sys::System,
    component::StaticInjection,
    data::Union{Float64, TimeSeriesData}
) -&gt; Any
</code></pre><p>Set the fuel cost of the component&#39;s variable cost, which must be a <code>FuelCurve</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_function_timeseries.jl#L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_no_load_cost!-Tuple{System, StaticInjection, Union{Float64, TimeSeriesData}}" href="#PowerSystems.set_no_load_cost!-Tuple{System, StaticInjection, Union{Float64, TimeSeriesData}}"><code>PowerSystems.set_no_load_cost!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_no_load_cost!(
    sys::System,
    component::StaticInjection,
    data::Union{Float64, TimeSeriesData}
) -&gt; Union{Float64, TimeSeriesKey}
</code></pre><p>Set the no-load cost for a <code>StaticInjection</code> device with a <code>MarketBidCost</code> to either a single number or a time series.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: PowerSystem System</li><li><code>component::StaticInjection</code>: Static injection device</li><li><code>time_series_data::Union{Float64, IS.TimeSeriesData},</code>: the data. If a time series, must be of eltype <code>Float64</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_function_timeseries.jl#L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_service_bid!-Tuple{System, StaticInjection, Service, TimeSeriesData}" href="#PowerSystems.set_service_bid!-Tuple{System, StaticInjection, Service, TimeSeriesData}"><code>PowerSystems.set_service_bid!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_service_bid!(
    sys::System,
    component::StaticInjection,
    service::Service,
    time_series_data::TimeSeriesData
)
</code></pre><p>Adds service bids time-series data to the MarketBidCost.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: PowerSystem System</li><li><code>component::StaticInjection</code>: Static injection device</li><li><code>service::Service,</code>: Service for which the device is eligible to contribute</li><li><code>time_series_data::IS.TimeSeriesData</code>: TimeSeriesData</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_function_timeseries.jl#L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_start_up!-Tuple{System, StaticInjection, Union{@NamedTuple{hot::Float64, warm::Float64, cold::Float64}, TimeSeriesData}}" href="#PowerSystems.set_start_up!-Tuple{System, StaticInjection, Union{@NamedTuple{hot::Float64, warm::Float64, cold::Float64}, TimeSeriesData}}"><code>PowerSystems.set_start_up!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_start_up!(
    sys::System,
    component::StaticInjection,
    data::Union{@NamedTuple{hot::Float64, warm::Float64, cold::Float64}, TimeSeriesData}
) -&gt; Union{@NamedTuple{hot::Float64, warm::Float64, cold::Float64}, TimeSeriesKey}
</code></pre><p>Set the startup cost for a <code>StaticInjection</code> device with a <code>MarketBidCost</code> to either a single <code>StartUpStages</code> or a time series.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: PowerSystem System</li><li><code>component::StaticInjection</code>: Static injection device</li><li><code>time_series_data::Union{StartUpStages, IS.TimeSeriesData},</code>: the data. If a time series, must be of eltype <code>NTuple{3, Float64}</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_function_timeseries.jl#L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_variable_cost!-Tuple{System, ReserveDemandCurve, CostCurve{PiecewiseIncrementalCurve}}" href="#PowerSystems.set_variable_cost!-Tuple{System, ReserveDemandCurve, CostCurve{PiecewiseIncrementalCurve}}"><code>PowerSystems.set_variable_cost!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_variable_cost!(
    _::System,
    component::ReserveDemandCurve,
    data::CostCurve{PiecewiseIncrementalCurve}
) -&gt; CostCurve{PiecewiseIncrementalCurve}
</code></pre><p>Adds fixed energy market bids to the ReserveDemandCurve.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: PowerSystem System</li><li><code>component::ReserveDemandCurve</code>: the curve</li><li>`time<em>series</em>data::CostCurve{PiecewiseIncrementalCurve}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_function_timeseries.jl#L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_variable_cost!-Tuple{System, ReserveDemandCurve, Union{Nothing, TimeSeriesData}}" href="#PowerSystems.set_variable_cost!-Tuple{System, ReserveDemandCurve, Union{Nothing, TimeSeriesData}}"><code>PowerSystems.set_variable_cost!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_variable_cost!(
    sys::System,
    component::ReserveDemandCurve,
    data::Union{Nothing, TimeSeriesData}
) -&gt; TimeSeriesKey
</code></pre><p>Adds energy market bids time-series to the ReserveDemandCurve.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: PowerSystem System</li><li><code>component::ReserveDemandCurve</code>: the curve</li><li><code>time_series_data::IS.TimeSeriesData</code>: TimeSeriesData</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_function_timeseries.jl#L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_variable_cost!-Tuple{System, StaticInjection, Union{Nothing, TimeSeriesData, CostCurve{PiecewiseIncrementalCurve}}}" href="#PowerSystems.set_variable_cost!-Tuple{System, StaticInjection, Union{Nothing, TimeSeriesData, CostCurve{PiecewiseIncrementalCurve}}}"><code>PowerSystems.set_variable_cost!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_variable_cost!(
    sys::System,
    component::StaticInjection,
    data::Union{Nothing, TimeSeriesData, CostCurve{PiecewiseIncrementalCurve}}
) -&gt; Any
</code></pre><p>Set the variable cost bid for a <code>StaticInjection</code> device with a <code>MarketBidCost</code>.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: PowerSystem System</li><li><code>component::StaticInjection</code>: Static injection device</li><li><code>time_series_data::Union{Nothing, IS.TimeSeriesData, CostCurve{PiecewiseIncrementalCurve}},</code>: the data. If a time series, must be of eltype <code>PiecewiseStepData</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/cost_function_timeseries.jl#L248">source</a></section></article><h2 id="TimeSeries"><a class="docs-heading-anchor" href="#TimeSeries">TimeSeries</a><a id="TimeSeries-1"></a><a class="docs-heading-anchor-permalink" href="#TimeSeries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.TimeSeriesData" href="#InfrastructureSystems.TimeSeriesData"><code>InfrastructureSystems.TimeSeriesData</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Abstract type for time series stored in the system. Components store references to these through TimeSeriesMetadata values so that data can reside on storage media instead of memory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.TimeSeriesMetadata" href="#InfrastructureSystems.TimeSeriesMetadata"><code>InfrastructureSystems.TimeSeriesMetadata</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Abstract type for time_series that are stored in a system. Users never create them or get access to them. Stores references to TimeSeriesData.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Deterministic" href="#InfrastructureSystems.Deterministic"><code>InfrastructureSystems.Deterministic</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Deterministic &lt;: AbstractDeterministic
    name::String
    data::SortedDict
    resolution::Dates.Period
    scaling_factor_multiplier::Union{Nothing, Function}
    internal::InfrastructureSystemsInternal
end</code></pre><p>A deterministic forecast for a particular data field in a Component.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: user-defined name</li><li><code>data::SortedDict</code>: timestamp - scalingfactor</li><li><code>resolution::Dates.Period</code>: forecast resolution</li><li><code>scaling_factor_multiplier::Union{Nothing, Function}</code>: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.</li><li><code>internal::InfrastructureSystemsInternal</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Deterministic-Tuple{AbstractString, AbstractDict{Dates.DateTime, &lt;:TimeSeries.TimeArray}}" href="#InfrastructureSystems.Deterministic-Tuple{AbstractString, AbstractDict{Dates.DateTime, &lt;:TimeSeries.TimeArray}}"><code>InfrastructureSystems.Deterministic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Deterministic(
    name::AbstractString,
    input_data::AbstractDict{Dates.DateTime, &lt;:TimeSeries.TimeArray};
    normalization_factor,
    scaling_factor_multiplier
) -&gt; Deterministic
</code></pre><p>Construct Deterministic from a Dict of TimeArrays.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>input_data::AbstractDict{Dates.DateTime, TimeSeries.TimeArray}</code>: time series data.</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li><li><code>timestamp = :timestamp</code>: If the values are DataFrames is passed then this must be the column name that contains timestamps.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Deterministic-Tuple{AbstractString, AbstractString, InfrastructureSystems.InfrastructureSystemsComponent, Dates.Period}" href="#InfrastructureSystems.Deterministic-Tuple{AbstractString, AbstractString, InfrastructureSystems.InfrastructureSystemsComponent, Dates.Period}"><code>InfrastructureSystems.Deterministic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Deterministic(
    name::AbstractString,
    filename::AbstractString,
    component::InfrastructureSystems.InfrastructureSystemsComponent,
    resolution::Dates.Period;
    normalization_factor,
    scaling_factor_multiplier
) -&gt; Deterministic
</code></pre><p>Construct Deterministic from a CSV file. The first column must be a timestamp in DateTime format and the columns the values in the forecast window.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>filename::AbstractString</code>: name of CSV file containing data</li><li><code>component::InfrastructureSystemsComponent</code>: component associated with the data</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Deterministic-Tuple{AbstractString, InfrastructureSystems.RawTimeSeries, Dates.Period}" href="#InfrastructureSystems.Deterministic-Tuple{AbstractString, InfrastructureSystems.RawTimeSeries, Dates.Period}"><code>InfrastructureSystems.Deterministic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Deterministic(
    name::AbstractString,
    series_data::InfrastructureSystems.RawTimeSeries,
    resolution::Dates.Period;
    normalization_factor,
    scaling_factor_multiplier
) -&gt; Deterministic
</code></pre><p>Construct Deterministic from RawTimeSeries.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Deterministic-Tuple{Deterministic, AbstractString}" href="#InfrastructureSystems.Deterministic-Tuple{Deterministic, AbstractString}"><code>InfrastructureSystems.Deterministic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Deterministic(
    src::Deterministic,
    name::AbstractString;
    scaling_factor_multiplier
) -&gt; Deterministic
</code></pre><p>Construct Deterministic that shares the data from an existing instance.</p><p>This is useful in cases where you want a component to use the same time series data for two different attributes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">resolution = Dates.Hour(1)
data = Dict(
    DateTime(&quot;2020-01-01T00:00:00&quot;) =&gt; ones(24),
    DateTime(&quot;2020-01-01T01:00:00&quot;) =&gt; ones(24),
)
# Define a Deterministic for the first attribute
forecast_max_active_power = Deterministic(
    &quot;max_active_power&quot;,
    data,
    resolution,
    scaling_factor_multiplier = get_max_active_power,
)
add_time_series!(sys, generator, forecast_max_active_power)
# Reuse time series for second attribute
forecast_max_reactive_power = Deterministic(
    forecast_max_active_power,
    &quot;max_reactive_power&quot;
    scaling_factor_multiplier = get_max_reactive_power,
)
add_time_series!(sys, generator, forecast_max_reactive_power)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Deterministic-Tuple{Deterministic, Any}" href="#InfrastructureSystems.Deterministic-Tuple{Deterministic, Any}"><code>InfrastructureSystems.Deterministic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Deterministic(
    forecast::Deterministic,
    data
) -&gt; Deterministic
</code></pre><p>Construct a new Deterministic from an existing instance and a subset of data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_data-Tuple{Deterministic}" href="#InfrastructureSystems.get_data-Tuple{Deterministic}"><code>InfrastructureSystems.get_data</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_data(value::Deterministic) -&gt; DataStructures.SortedDict
</code></pre><p>Get <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_name-Tuple{Deterministic}" href="#InfrastructureSystems.get_name-Tuple{Deterministic}"><code>InfrastructureSystems.get_name</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_name(value::Deterministic) -&gt; String
</code></pre><p>Get <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_resolution-Tuple{Deterministic}" href="#InfrastructureSystems.get_resolution-Tuple{Deterministic}"><code>InfrastructureSystems.get_resolution</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_resolution(value::Deterministic) -&gt; Dates.Period
</code></pre><p>Get <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>resolution</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_scaling_factor_multiplier-Tuple{Deterministic}" href="#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{Deterministic}"><code>InfrastructureSystems.get_scaling_factor_multiplier</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_scaling_factor_multiplier(
    value::Deterministic
) -&gt; Union{Nothing, Function}
</code></pre><p>Get <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.iterate_windows-Tuple{Deterministic}" href="#InfrastructureSystems.iterate_windows-Tuple{Deterministic}"><code>InfrastructureSystems.iterate_windows</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iterate_windows(
    forecast::Deterministic
) -&gt; Base.Generator{I, InfrastructureSystems.var&quot;#107#108&quot;{Deterministic}} where I&lt;:(DataStructures.SDMKeyIteration{T} where T&lt;:DataStructures.SortedDict)
</code></pre><p>Iterate over the windows in a forecast</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">for window in iterate_windows(forecast)
    @show values(maximum(window))
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_data!-Tuple{Deterministic, Any}" href="#InfrastructureSystems.set_data!-Tuple{Deterministic, Any}"><code>InfrastructureSystems.set_data!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_data!(value::Deterministic, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_name!-Tuple{Deterministic, Any}" href="#InfrastructureSystems.set_name!-Tuple{Deterministic, Any}"><code>InfrastructureSystems.set_name!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_name!(value::Deterministic, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_resolution!-Tuple{Deterministic, Any}" href="#InfrastructureSystems.set_resolution!-Tuple{Deterministic, Any}"><code>InfrastructureSystems.set_resolution!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_resolution!(value::Deterministic, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>resolution</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{Deterministic, Any}" href="#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{Deterministic, Any}"><code>InfrastructureSystems.set_scaling_factor_multiplier!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_scaling_factor_multiplier!(
    value::Deterministic,
    val
) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Probabilistic" href="#InfrastructureSystems.Probabilistic"><code>InfrastructureSystems.Probabilistic</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Probabilistic &lt;: Forecast
    name::String
    resolution::Dates.Period
    percentiles::Vector{Float64}
    data::SortedDict
    scaling_factor_multiplier::Union{Nothing, Function}
    internal::InfrastructureSystemsInternal
end</code></pre><p>A Probabilistic forecast for a particular data field in a Component.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: user-defined name</li><li><code>resolution::Dates.Period</code>: forecast resolution</li><li><code>percentiles::Vector{Float64}</code>: Percentiles for the probabilistic forecast</li><li><code>data::SortedDict</code>: timestamp - scalingfactor</li><li><code>scaling_factor_multiplier::Union{Nothing, Function}</code>: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.</li><li><code>internal::InfrastructureSystemsInternal</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Probabilistic-Tuple{AbstractString, AbstractDict, Vector, Dates.Period}" href="#InfrastructureSystems.Probabilistic-Tuple{AbstractString, AbstractDict, Vector, Dates.Period}"><code>InfrastructureSystems.Probabilistic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Probabilistic(
    name::AbstractString,
    input_data::AbstractDict,
    percentiles::Vector,
    resolution::Dates.Period;
    normalization_factor,
    scaling_factor_multiplier
) -&gt; Probabilistic
</code></pre><p>Construct Probabilistic from a SortedDict of Arrays.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>input_data::AbstractDict{Dates.DateTime, Matrix{Float64}}</code>: time series data.</li><li><code>percentiles</code>: Percentiles represented in the probabilistic forecast</li><li><code>resolution::Dates.Period</code>: The resolution of the forecast in Dates.Period`</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Probabilistic-Tuple{AbstractString, AbstractDict{Dates.DateTime, &lt;:TimeSeries.TimeArray}, Vector{Float64}}" href="#InfrastructureSystems.Probabilistic-Tuple{AbstractString, AbstractDict{Dates.DateTime, &lt;:TimeSeries.TimeArray}, Vector{Float64}}"><code>InfrastructureSystems.Probabilistic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Probabilistic(
    name::AbstractString,
    input_data::AbstractDict{Dates.DateTime, &lt;:TimeSeries.TimeArray},
    percentiles::Vector{Float64};
    normalization_factor,
    scaling_factor_multiplier
) -&gt; Probabilistic
</code></pre><p>Construct Probabilistic from a Dict of TimeArrays.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>input_data::AbstractDict{Dates.DateTime, TimeSeries.TimeArray}</code>: time series data.</li><li><code>percentiles</code>: Percentiles represented in the probabilistic forecast</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li><li><code>timestamp = :timestamp</code>: If the values are DataFrames is passed then this must be the column name that contains timestamps.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Probabilistic-Tuple{AbstractString, InfrastructureSystems.RawTimeSeries, Vector, Dates.Period}" href="#InfrastructureSystems.Probabilistic-Tuple{AbstractString, InfrastructureSystems.RawTimeSeries, Vector, Dates.Period}"><code>InfrastructureSystems.Probabilistic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Probabilistic(
    name::AbstractString,
    series_data::InfrastructureSystems.RawTimeSeries,
    percentiles::Vector,
    resolution::Dates.Period;
    normalization_factor,
    scaling_factor_multiplier
) -&gt; Probabilistic
</code></pre><p>Construct Deterministic from RawTimeSeries.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Probabilistic-Tuple{Probabilistic, AbstractString}" href="#InfrastructureSystems.Probabilistic-Tuple{Probabilistic, AbstractString}"><code>InfrastructureSystems.Probabilistic</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Probabilistic(
    src::Probabilistic,
    name::AbstractString;
    scaling_factor_multiplier
) -&gt; Probabilistic
</code></pre><p>Construct a Probabilistic that shares the data from an existing instance.</p><p>This is useful in cases where you want a component to use the same time series data for two different attributes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_data-Tuple{Probabilistic}" href="#InfrastructureSystems.get_data-Tuple{Probabilistic}"><code>InfrastructureSystems.get_data</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_data(value::Probabilistic) -&gt; DataStructures.SortedDict
</code></pre><p>Get <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_name-Tuple{Probabilistic}" href="#InfrastructureSystems.get_name-Tuple{Probabilistic}"><code>InfrastructureSystems.get_name</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_name(value::Probabilistic) -&gt; String
</code></pre><p>Get <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_percentiles-Tuple{Probabilistic}" href="#InfrastructureSystems.get_percentiles-Tuple{Probabilistic}"><code>InfrastructureSystems.get_percentiles</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_percentiles(value::Probabilistic) -&gt; Vector{Float64}
</code></pre><p>Get <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>percentiles</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_resolution-Tuple{Probabilistic}" href="#InfrastructureSystems.get_resolution-Tuple{Probabilistic}"><code>InfrastructureSystems.get_resolution</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_resolution(value::Probabilistic) -&gt; Dates.Period
</code></pre><p>Get <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>resolution</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_scaling_factor_multiplier-Tuple{Probabilistic}" href="#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{Probabilistic}"><code>InfrastructureSystems.get_scaling_factor_multiplier</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_scaling_factor_multiplier(
    value::Probabilistic
) -&gt; Union{Nothing, Function}
</code></pre><p>Get <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.iterate_windows-Tuple{Probabilistic}" href="#InfrastructureSystems.iterate_windows-Tuple{Probabilistic}"><code>InfrastructureSystems.iterate_windows</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iterate_windows(
    forecast::Probabilistic
) -&gt; Base.Generator{I, InfrastructureSystems.var&quot;#107#108&quot;{Probabilistic}} where I&lt;:(DataStructures.SDMKeyIteration{T} where T&lt;:DataStructures.SortedDict)
</code></pre><p>Iterate over the windows in a forecast</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">for window in iterate_windows(forecast)
    @show values(maximum(window))
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_data!-Tuple{Probabilistic, Any}" href="#InfrastructureSystems.set_data!-Tuple{Probabilistic, Any}"><code>InfrastructureSystems.set_data!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_data!(value::Probabilistic, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_name!-Tuple{Probabilistic, Any}" href="#InfrastructureSystems.set_name!-Tuple{Probabilistic, Any}"><code>InfrastructureSystems.set_name!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_name!(value::Probabilistic, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_percentiles!-Tuple{Probabilistic, Any}" href="#InfrastructureSystems.set_percentiles!-Tuple{Probabilistic, Any}"><code>InfrastructureSystems.set_percentiles!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_percentiles!(value::Probabilistic, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>percentiles</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_resolution!-Tuple{Probabilistic, Any}" href="#InfrastructureSystems.set_resolution!-Tuple{Probabilistic, Any}"><code>InfrastructureSystems.set_resolution!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_resolution!(value::Probabilistic, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>resolution</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{Probabilistic, Any}" href="#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{Probabilistic, Any}"><code>InfrastructureSystems.set_scaling_factor_multiplier!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_scaling_factor_multiplier!(
    value::Probabilistic,
    val
) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Scenarios" href="#InfrastructureSystems.Scenarios"><code>InfrastructureSystems.Scenarios</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Scenarios &lt;: Forecast
    name::String
    resolution::Dates.Period
    scenario_count::Int64
    data::SortedDict
    scaling_factor_multiplier::Union{Nothing, Function}
    internal::InfrastructureSystemsInternal
end</code></pre><p>A Discrete Scenario Based time series for a particular data field in a Component.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: user-defined name</li><li><code>resolution::Dates.Period</code>: forecast resolution</li><li><code>scenario_count::Int64</code>: Number of scenarios</li><li><code>data::SortedDict</code>: timestamp - scalingfactor</li><li><code>scaling_factor_multiplier::Union{Nothing, Function}</code>: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.</li><li><code>internal::InfrastructureSystemsInternal</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Scenarios-Tuple{AbstractString, AbstractDict, Dates.Period}" href="#InfrastructureSystems.Scenarios-Tuple{AbstractString, AbstractDict, Dates.Period}"><code>InfrastructureSystems.Scenarios</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Scenarios(
    name::AbstractString,
    input_data::AbstractDict,
    resolution::Dates.Period;
    normalization_factor,
    scaling_factor_multiplier
) -&gt; Scenarios
</code></pre><p>Construct Scenarios from a SortedDict of Arrays.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>input_data::AbstractDict{Dates.DateTime, Matrix{Float64}}</code>: time series data.</li><li><code>resolution::Dates.Period</code>: The resolution of the forecast in Dates.Period`</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Scenarios-Tuple{AbstractString, AbstractDict{Dates.DateTime, &lt;:TimeSeries.TimeArray}}" href="#InfrastructureSystems.Scenarios-Tuple{AbstractString, AbstractDict{Dates.DateTime, &lt;:TimeSeries.TimeArray}}"><code>InfrastructureSystems.Scenarios</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Scenarios(
    name::AbstractString,
    input_data::AbstractDict{Dates.DateTime, &lt;:TimeSeries.TimeArray};
    normalization_factor,
    scaling_factor_multiplier
) -&gt; Scenarios
</code></pre><p>Construct Scenarios from a Dict of TimeArrays.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>input_data::AbstractDict{Dates.DateTime, TimeSeries.TimeArray}</code>: time series data.</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li><li><code>timestamp = :timestamp</code>: If the values are DataFrames is passed then this must be the column name that contains timestamps.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Scenarios-Tuple{Scenarios, AbstractString}" href="#InfrastructureSystems.Scenarios-Tuple{Scenarios, AbstractString}"><code>InfrastructureSystems.Scenarios</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Scenarios(
    src::Scenarios,
    name::AbstractString;
    scaling_factor_multiplier
) -&gt; Scenarios
</code></pre><p>Construct Scenarios that shares the data from an existing instance.</p><p>This is useful in cases where you want a component to use the same time series data for two different attributes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_data-Tuple{Scenarios}" href="#InfrastructureSystems.get_data-Tuple{Scenarios}"><code>InfrastructureSystems.get_data</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_data(value::Scenarios) -&gt; DataStructures.SortedDict
</code></pre><p>Get <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_name-Tuple{Scenarios}" href="#InfrastructureSystems.get_name-Tuple{Scenarios}"><code>InfrastructureSystems.get_name</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_name(value::Scenarios) -&gt; String
</code></pre><p>Get <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_resolution-Tuple{Scenarios}" href="#InfrastructureSystems.get_resolution-Tuple{Scenarios}"><code>InfrastructureSystems.get_resolution</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_resolution(value::Scenarios) -&gt; Dates.Period
</code></pre><p>Get <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>resolution</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_scaling_factor_multiplier-Tuple{Scenarios}" href="#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{Scenarios}"><code>InfrastructureSystems.get_scaling_factor_multiplier</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_scaling_factor_multiplier(
    value::Scenarios
) -&gt; Union{Nothing, Function}
</code></pre><p>Get <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_scenario_count-Tuple{Scenarios}" href="#InfrastructureSystems.get_scenario_count-Tuple{Scenarios}"><code>InfrastructureSystems.get_scenario_count</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_scenario_count(value::Scenarios) -&gt; Int64
</code></pre><p>Get <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>scenario_count</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.iterate_windows-Tuple{Scenarios}" href="#InfrastructureSystems.iterate_windows-Tuple{Scenarios}"><code>InfrastructureSystems.iterate_windows</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iterate_windows(
    forecast::Scenarios
) -&gt; Base.Generator{I, InfrastructureSystems.var&quot;#107#108&quot;{Scenarios}} where I&lt;:(DataStructures.SDMKeyIteration{T} where T&lt;:DataStructures.SortedDict)
</code></pre><p>Iterate over the windows in a forecast</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">for window in iterate_windows(forecast)
    @show values(maximum(window))
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_data!-Tuple{Scenarios, Any}" href="#InfrastructureSystems.set_data!-Tuple{Scenarios, Any}"><code>InfrastructureSystems.set_data!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_data!(value::Scenarios, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_name!-Tuple{Scenarios, Any}" href="#InfrastructureSystems.set_name!-Tuple{Scenarios, Any}"><code>InfrastructureSystems.set_name!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_name!(value::Scenarios, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_resolution!-Tuple{Scenarios, Any}" href="#InfrastructureSystems.set_resolution!-Tuple{Scenarios, Any}"><code>InfrastructureSystems.set_resolution!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_resolution!(value::Scenarios, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>resolution</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{Scenarios, Any}" href="#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{Scenarios, Any}"><code>InfrastructureSystems.set_scaling_factor_multiplier!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_scaling_factor_multiplier!(value::Scenarios, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_scenario_count!-Tuple{Scenarios, Any}" href="#InfrastructureSystems.set_scenario_count!-Tuple{Scenarios, Any}"><code>InfrastructureSystems.set_scenario_count!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_scenario_count!(value::Scenarios, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a> <code>scenario_count</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.DeterministicSingleTimeSeries" href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>InfrastructureSystems.DeterministicSingleTimeSeries</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct DeterministicSingleTimeSeries &lt;: AbstractDeterministic
    single_time_series::SingleTimeSeries
    initial_timestamp::Dates.DateTime
    interval::Dates.Period
    count::Int
    horizon::Int
end</code></pre><p>A deterministic forecast that wraps a <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a></p><p><code>DeterministicSingleTimeSeries</code> behaves exactly like a <a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a>, but instead of storing windows at each initial time it provides a view into the existing <code>SingleTimeSeries</code> at incrementing offsets. This avoids large data duplications when  there are the overlapping windows between forecasts. </p><p>Can be used as a perfect forecast based on historical data when real forecast data is unavailable. </p><p><strong>Arguments</strong></p><ul><li><code>single_time_series::SingleTimeSeries</code>: wrapped <code>SingleTimeSeries</code> object</li><li><code>initial_timestamp::Dates.DateTime</code>: time series availability time</li><li><code>interval::Dates.Period</code>: time step between forecast windows</li><li><code>count::Int</code>: number of forecast windows</li><li><code>horizon::Int</code>: length of this time series</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.SingleTimeSeries" href="#InfrastructureSystems.SingleTimeSeries"><code>InfrastructureSystems.SingleTimeSeries</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct SingleTimeSeries &lt;: StaticTimeSeries
    name::String
    data::TimeSeries.TimeArray
    scaling_factor_multiplier::Union{Nothing, Function}
    internal::InfrastructureSystemsInternal
end</code></pre><p>A single column of time series data for a particular data field in a Component.</p><p>In contrast with a forecast, this can represent one continual time series, such as a series of historical measurements or realizations or a single scenario (e.g. a weather year or different input assumptions).</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: user-defined name</li><li><code>data::TimeSeries.TimeArray</code>: timestamp - scalingfactor</li><li><code>resolution::Dates.Period</code>: Time duration between steps in the time series. The resolution must be the same throughout the time series</li><li><code>scaling_factor_multiplier::Union{Nothing, Function}</code>: Applicable when the time series data are scaling factors. Called on the associated component to convert the values.</li><li><code>internal::InfrastructureSystemsInternal</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.SingleTimeSeries-Tuple{AbstractString, AbstractString, InfrastructureSystems.InfrastructureSystemsComponent, Dates.Period}" href="#InfrastructureSystems.SingleTimeSeries-Tuple{AbstractString, AbstractString, InfrastructureSystems.InfrastructureSystemsComponent, Dates.Period}"><code>InfrastructureSystems.SingleTimeSeries</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SingleTimeSeries(
    name::AbstractString,
    filename::AbstractString,
    component::InfrastructureSystems.InfrastructureSystemsComponent,
    resolution::Dates.Period;
    normalization_factor,
    scaling_factor_multiplier
) -&gt; SingleTimeSeries
</code></pre><p>Construct SingleTimeSeries from a CSV file. The file must have a column that is the name of the component.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>filename::AbstractString</code>: name of CSV file containing data</li><li><code>component::InfrastructureSystemsComponent</code>: component associated with the data</li><li><code>resolution::Dates.Period</code>: resolution of the time series</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.SingleTimeSeries-Tuple{AbstractString, Union{DataFrames.DataFrame, TimeSeries.TimeArray}}" href="#InfrastructureSystems.SingleTimeSeries-Tuple{AbstractString, Union{DataFrames.DataFrame, TimeSeries.TimeArray}}"><code>InfrastructureSystems.SingleTimeSeries</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SingleTimeSeries(
    name::AbstractString,
    data::Union{DataFrames.DataFrame, TimeSeries.TimeArray};
    normalization_factor,
    scaling_factor_multiplier,
    timestamp
) -&gt; SingleTimeSeries
</code></pre><p>Construct SingleTimeSeries from a TimeArray or DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>name::AbstractString</code>: user-defined name</li><li><code>data::Union{TimeSeries.TimeArray, DataFrames.DataFrame}</code>: time series data</li><li><code>normalization_factor::NormalizationFactor = 1.0</code>: optional normalization factor to apply to each data entry</li><li><code>scaling_factor_multiplier::Union{Nothing, Function} = nothing</code>: If the data are scaling factors then this function will be called on the component and applied to the data when <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a> is called.</li><li><code>timestamp = :timestamp</code>: If a DataFrame is passed then this must be the column name that contains timestamps.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.SingleTimeSeries-Tuple{SingleTimeSeries, AbstractString}" href="#InfrastructureSystems.SingleTimeSeries-Tuple{SingleTimeSeries, AbstractString}"><code>InfrastructureSystems.SingleTimeSeries</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SingleTimeSeries(
    src::SingleTimeSeries,
    name::AbstractString;
    scaling_factor_multiplier
) -&gt; SingleTimeSeries
</code></pre><p>Construct SingleTimeSeries that shares the data from an existing instance.</p><p>This is useful in cases where you want a component to use the same time series data for two different attribtues.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.SingleTimeSeries-Tuple{SingleTimeSeries, TimeSeries.TimeArray}" href="#InfrastructureSystems.SingleTimeSeries-Tuple{SingleTimeSeries, TimeSeries.TimeArray}"><code>InfrastructureSystems.SingleTimeSeries</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SingleTimeSeries(
    time_series::SingleTimeSeries,
    data::TimeSeries.TimeArray
) -&gt; Any
</code></pre><p>Creates a new SingleTimeSeries from an existing instance and a subset of data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.SingleTimeSeries-Tuple{String, Dates.Period, Dates.DateTime, Int64}" href="#InfrastructureSystems.SingleTimeSeries-Tuple{String, Dates.Period, Dates.DateTime, Int64}"><code>InfrastructureSystems.SingleTimeSeries</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SingleTimeSeries(
    name::String,
    resolution::Dates.Period,
    initial_time::Dates.DateTime,
    time_steps::Int64
) -&gt; SingleTimeSeries
</code></pre><p>Construct SingleTimeSeries after constructing a TimeArray from <code>initial_time</code> and <code>time_steps</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.from-Tuple{SingleTimeSeries, Any}" href="#InfrastructureSystems.from-Tuple{SingleTimeSeries, Any}"><code>InfrastructureSystems.from</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from(
    time_series::SingleTimeSeries,
    timestamp
) -&gt; SingleTimeSeries
</code></pre><p>Return a time_series truncated starting with timestamp.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_count-Tuple{DeterministicSingleTimeSeries}" href="#InfrastructureSystems.get_count-Tuple{DeterministicSingleTimeSeries}"><code>InfrastructureSystems.get_count</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_count(value::DeterministicSingleTimeSeries) -&gt; Int64
</code></pre><p>Get <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>count</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_data-Tuple{SingleTimeSeries}" href="#InfrastructureSystems.get_data-Tuple{SingleTimeSeries}"><code>InfrastructureSystems.get_data</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_data(value::SingleTimeSeries) -&gt; TimeSeries.TimeArray
</code></pre><p>Get <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_horizon-Tuple{DeterministicSingleTimeSeries}" href="#InfrastructureSystems.get_horizon-Tuple{DeterministicSingleTimeSeries}"><code>InfrastructureSystems.get_horizon</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_horizon(
    value::DeterministicSingleTimeSeries
) -&gt; Dates.Period
</code></pre><p>Get <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>horizon</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_initial_timestamp-Tuple{DeterministicSingleTimeSeries}" href="#InfrastructureSystems.get_initial_timestamp-Tuple{DeterministicSingleTimeSeries}"><code>InfrastructureSystems.get_initial_timestamp</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_initial_timestamp(
    value::DeterministicSingleTimeSeries
) -&gt; Dates.DateTime
</code></pre><p>Get <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>initial_timestamp</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_interval-Tuple{DeterministicSingleTimeSeries}" href="#InfrastructureSystems.get_interval-Tuple{DeterministicSingleTimeSeries}"><code>InfrastructureSystems.get_interval</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_interval(
    value::DeterministicSingleTimeSeries
) -&gt; Dates.Period
</code></pre><p>Get <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>interval</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_name-Tuple{SingleTimeSeries}" href="#InfrastructureSystems.get_name-Tuple{SingleTimeSeries}"><code>InfrastructureSystems.get_name</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_name(value::SingleTimeSeries) -&gt; String
</code></pre><p>Get <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_resolution-Tuple{SingleTimeSeries}" href="#InfrastructureSystems.get_resolution-Tuple{SingleTimeSeries}"><code>InfrastructureSystems.get_resolution</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_resolution(value::SingleTimeSeries) -&gt; Dates.Period
</code></pre><p>Get <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a> <code>resolution</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_scaling_factor_multiplier-Tuple{SingleTimeSeries}" href="#InfrastructureSystems.get_scaling_factor_multiplier-Tuple{SingleTimeSeries}"><code>InfrastructureSystems.get_scaling_factor_multiplier</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_scaling_factor_multiplier(
    value::SingleTimeSeries
) -&gt; Union{Nothing, Function}
</code></pre><p>Get <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_single_time_series-Tuple{DeterministicSingleTimeSeries}" href="#InfrastructureSystems.get_single_time_series-Tuple{DeterministicSingleTimeSeries}"><code>InfrastructureSystems.get_single_time_series</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_single_time_series(
    value::DeterministicSingleTimeSeries
) -&gt; SingleTimeSeries
</code></pre><p>Get <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>single_time_series</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.head-Tuple{SingleTimeSeries}" href="#InfrastructureSystems.head-Tuple{SingleTimeSeries}"><code>InfrastructureSystems.head</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">head(time_series::SingleTimeSeries) -&gt; Any
</code></pre><p>Return a time_series with only the first num values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.iterate_windows-Tuple{DeterministicSingleTimeSeries}" href="#InfrastructureSystems.iterate_windows-Tuple{DeterministicSingleTimeSeries}"><code>InfrastructureSystems.iterate_windows</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iterate_windows(
    forecast::DeterministicSingleTimeSeries
) -&gt; Any
</code></pre><p>Iterate over the windows in a forecast</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">for window in iterate_windows(forecast)
    @show values(maximum(window))
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_count!-Tuple{DeterministicSingleTimeSeries, Any}" href="#InfrastructureSystems.set_count!-Tuple{DeterministicSingleTimeSeries, Any}"><code>InfrastructureSystems.set_count!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_count!(value::DeterministicSingleTimeSeries, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>count</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_data!-Tuple{SingleTimeSeries, Any}" href="#InfrastructureSystems.set_data!-Tuple{SingleTimeSeries, Any}"><code>InfrastructureSystems.set_data!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_data!(value::SingleTimeSeries, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a> <code>data</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_horizon!-Tuple{DeterministicSingleTimeSeries, Any}" href="#InfrastructureSystems.set_horizon!-Tuple{DeterministicSingleTimeSeries, Any}"><code>InfrastructureSystems.set_horizon!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_horizon!(
    value::DeterministicSingleTimeSeries,
    val
) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>horizon</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_initial_timestamp!-Tuple{DeterministicSingleTimeSeries, Any}" href="#InfrastructureSystems.set_initial_timestamp!-Tuple{DeterministicSingleTimeSeries, Any}"><code>InfrastructureSystems.set_initial_timestamp!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_initial_timestamp!(
    value::DeterministicSingleTimeSeries,
    val
) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>initial_timestamp</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_interval!-Tuple{DeterministicSingleTimeSeries, Any}" href="#InfrastructureSystems.set_interval!-Tuple{DeterministicSingleTimeSeries, Any}"><code>InfrastructureSystems.set_interval!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_interval!(
    value::DeterministicSingleTimeSeries,
    val
) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>interval</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_name!-Tuple{SingleTimeSeries, Any}" href="#InfrastructureSystems.set_name!-Tuple{SingleTimeSeries, Any}"><code>InfrastructureSystems.set_name!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_name!(value::SingleTimeSeries, val) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a> <code>name</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{SingleTimeSeries, Any}" href="#InfrastructureSystems.set_scaling_factor_multiplier!-Tuple{SingleTimeSeries, Any}"><code>InfrastructureSystems.set_scaling_factor_multiplier!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_scaling_factor_multiplier!(
    value::SingleTimeSeries,
    val
) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.SingleTimeSeries"><code>SingleTimeSeries</code></a> <code>scaling_factor_multiplier</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_single_time_series!-Tuple{DeterministicSingleTimeSeries, Any}" href="#InfrastructureSystems.set_single_time_series!-Tuple{DeterministicSingleTimeSeries, Any}"><code>InfrastructureSystems.set_single_time_series!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_single_time_series!(
    value::DeterministicSingleTimeSeries,
    val
) -&gt; Any
</code></pre><p>Set <a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a> <code>single_time_series</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.tail-Tuple{SingleTimeSeries}" href="#InfrastructureSystems.tail-Tuple{SingleTimeSeries}"><code>InfrastructureSystems.tail</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tail(time_series::SingleTimeSeries) -&gt; Any
</code></pre><p>Return a time_series with only the ending num values.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.to-Tuple{SingleTimeSeries, Any}" href="#InfrastructureSystems.to-Tuple{SingleTimeSeries, Any}"><code>InfrastructureSystems.to</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to(
    time_series::SingleTimeSeries,
    timestamp
) -&gt; SingleTimeSeries
</code></pre><p>Return a time_series truncated after timestamp.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.when-Tuple{SingleTimeSeries, Function, Integer}" href="#InfrastructureSystems.when-Tuple{SingleTimeSeries, Function, Integer}"><code>InfrastructureSystems.when</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">when(
    time_series::SingleTimeSeries,
    period::Function,
    t::Integer
) -&gt; Any
</code></pre><p>Refer to TimeSeries.when(). Underlying data is copied.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.Forecast" href="#InfrastructureSystems.Forecast"><code>InfrastructureSystems.Forecast</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Supertype for forecast time series Current concrete subtypes are:</p><ul><li><a href="#InfrastructureSystems.Deterministic"><code>Deterministic</code></a></li><li><a href="#InfrastructureSystems.DeterministicSingleTimeSeries"><code>DeterministicSingleTimeSeries</code></a></li><li><a href="#InfrastructureSystems.Scenarios"><code>Scenarios</code></a></li><li><a href="#InfrastructureSystems.Probabilistic"><code>Probabilistic</code></a></li></ul><p>Subtypes of Forecast must implement:</p><ul><li><code>get_horizon_count</code></li><li><code>get_initial_times</code></li><li><code>get_initial_timestamp</code></li><li><code>get_name</code></li><li><code>get_scaling_factor_multiplier</code></li><li><code>get_window</code></li><li><code>iterate_windows</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_initial_times-Tuple{Forecast}" href="#InfrastructureSystems.get_initial_times-Tuple{Forecast}"><code>InfrastructureSystems.get_initial_times</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_initial_times(
    f::Forecast
) -&gt; DataStructures.SDMKeyIteration{T} where T&lt;:DataStructures.SortedDict
</code></pre><p>Return the initial times in the forecast.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_total_period-Tuple{Forecast}" href="#InfrastructureSystems.get_total_period-Tuple{Forecast}"><code>InfrastructureSystems.get_total_period</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_total_period(f::Forecast) -&gt; Any
</code></pre><p>Return the total period covered by the forecast.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_window-Tuple{Forecast, Int64}" href="#InfrastructureSystems.get_window-Tuple{Forecast, Int64}"><code>InfrastructureSystems.get_window</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_window(forecast::Forecast, index::Int64; len) -&gt; Any
</code></pre><p>Return the forecast window corresponsing to interval index.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.index_to_initial_time-Tuple{Forecast, Int64}" href="#InfrastructureSystems.index_to_initial_time-Tuple{Forecast, Int64}"><code>InfrastructureSystems.index_to_initial_time</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_to_initial_time(
    forecast::Forecast,
    index::Int64
) -&gt; Any
</code></pre><p>Return the Dates.DateTime corresponding to an interval index.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.make_time_array-Tuple{Forecast, Dates.DateTime}" href="#InfrastructureSystems.make_time_array-Tuple{Forecast, Dates.DateTime}"><code>InfrastructureSystems.make_time_array</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_time_array(
    forecast::Forecast,
    start_time::Dates.DateTime;
    len
) -&gt; Any
</code></pre><p>Return a TimeSeries.TimeArray for one forecast window.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_next_time-Tuple{InfrastructureSystems.TimeSeriesCache}" href="#InfrastructureSystems.get_next_time-Tuple{InfrastructureSystems.TimeSeriesCache}"><code>InfrastructureSystems.get_next_time</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_next_time(
    cache::InfrastructureSystems.TimeSeriesCache
) -&gt; Any
</code></pre><p>Return the timestamp for the next read with <a href="#InfrastructureSystems.get_next_time_series_array!-Tuple{InfrastructureSystems.TimeSeriesCache}"><code>get_next_time_series_array!</code></a>.</p><p>Return <code>nothing</code> if all data has been read.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_next_time_series_array!-Tuple{InfrastructureSystems.TimeSeriesCache}" href="#InfrastructureSystems.get_next_time_series_array!-Tuple{InfrastructureSystems.TimeSeriesCache}"><code>InfrastructureSystems.get_next_time_series_array!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_next_time_series_array!(
    cache::InfrastructureSystems.TimeSeriesCache
) -&gt; Any
</code></pre><p>Return the next TimeSeries.TimeArray.</p><p>Returns <code>nothing</code> when all data has been read. Call <a href="api/@ref"><code>reset!</code></a> to restart. Call <a href="#InfrastructureSystems.get_next_time-Tuple{InfrastructureSystems.TimeSeriesCache}"><code>get_next_time</code></a> to check the start time.</p><p>Reads from storage if the data is not already in cache.</p><p><strong>Arguments</strong></p><ul><li><code>cache::StaticTimeSeriesCache</code>: cached instance</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">cache = ForecastCache(Deterministic, component, &quot;max_active_power&quot;)
window1 = get_next_time_series_array!(cache)
window2 = get_next_time_series_array!(cache)</code></pre></div></section></article><h2 id="System"><a class="docs-heading-anchor" href="#System">System</a><a id="System-1"></a><a class="docs-heading-anchor-permalink" href="#System" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System" href="#PowerSystems.System"><code>PowerSystems.System</code></a> â <span class="docstring-category">Type</span></header><section><div><p>System</p><p>A power system defined by fields for base_power, components, and time series.</p><pre><code class="language-julia hljs">System(base_power)
System(base_power, buses, components...)
System(base_power, buses, generators, loads, branches, storage, services; kwargs...)
System(base_power, buses, generators, loads; kwargs...)
System(file; kwargs...)
System(; buses, generators, loads, branches, storage, base_power, services, kwargs...)
System(; kwargs...)</code></pre><p><strong>Arguments</strong></p><ul><li><code>base_power::Float64</code>: the base power value for the system</li><li><code>buses::Vector{ACBus}</code>: an array of buses</li><li><code>components...</code>: Each element must be an iterable containing subtypes of Component.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>ext::Dict</code>: Contains user-defined parameters. Should only contain standard types.</li><li><code>runchecks::Bool</code>: Run available checks on input fields and when add_component! is called. Throws InvalidValue if an error is found.</li><li><code>time_series_in_memory::Bool=false</code>: Store time series data in memory instead of HDF5.</li><li><code>enable_compression::Bool=false</code>: Enable compression of time series data in HDF5.</li><li><code>compression::CompressionSettings</code>: Allows customization of HDF5 compression settings.</li><li><code>config_path::String</code>: specify path to validation config file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{AbstractString, AbstractString}" href="#PowerSystems.System-Tuple{AbstractString, AbstractString}"><code>PowerSystems.System</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(
    sys_file::AbstractString,
    dyr_file::AbstractString;
    kwargs...
) -&gt; Any
</code></pre><p>Parse static and dynamic data directly from PSS/e text files. Automatically generates all the relationships between the available dynamic injection models and the static counterpart</p><p>Each dictionary indexed by id contains a vector with 5 of its components:</p><ul><li>Machine</li><li>Shaft</li><li>AVR</li><li>TurbineGov</li><li>PSS</li></ul><p>Files must be parsed from a .raw file (PTI data format) and a .dyr file.</p><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">raw_file = &quot;Example.raw&quot;
dyr_file = &quot;Example.dyr&quot;
sys = System(raw_file, dyr_file)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{AbstractString}" href="#PowerSystems.System-Tuple{AbstractString}"><code>PowerSystems.System</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(
    file_path::AbstractString;
    assign_new_uuids,
    kwargs...
) -&gt; Any
</code></pre><p>Constructs a System from a file path ending with .m, .RAW, or .json</p><p>If the file is JSON then assign<em>new</em>uuids = true will generate new UUIDs for the system and all components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{Any, Number}" href="#PowerSystems.System-Tuple{Any, Number}"><code>PowerSystems.System</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(
    data,
    base_power::Number;
    internal,
    kwargs...
) -&gt; System
</code></pre><p>Construct a <code>System</code> from <code>InfrastructureSystems.SystemData</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{Float64, Vector{ACBus}, Vararg{Any}}" href="#PowerSystems.System-Tuple{Float64, Vector{ACBus}, Vararg{Any}}"><code>PowerSystems.System</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(
    base_power::Float64,
    buses::Vector{ACBus},
    components...;
    kwargs...
) -&gt; System
</code></pre><p>System constructor when components are constructed externally.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{Nothing}" href="#PowerSystems.System-Tuple{Nothing}"><code>PowerSystems.System</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(
    ::Nothing;
    buses,
    generators,
    loads,
    branches,
    storage,
    base_power,
    services,
    kwargs...
) -&gt; System
</code></pre><p>Constructs a non-functional System for demo purposes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{Number}" href="#PowerSystems.System-Tuple{Number}"><code>PowerSystems.System</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(base_power::Number; kwargs...) -&gt; System
</code></pre><p>Construct an empty <code>System</code>. Useful for building a System while parsing raw data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{PowerSystemTableData}" href="#PowerSystems.System-Tuple{PowerSystemTableData}"><code>PowerSystems.System</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(
    data::PowerSystemTableData;
    time_series_resolution,
    time_series_in_memory,
    time_series_directory,
    runchecks,
    kwargs...
) -&gt; System
</code></pre><p>Construct a System from PowerSystemTableData data.</p><p><strong>Arguments</strong></p><ul><li><code>time_series_resolution::Union{DateTime, Nothing}=nothing</code>: only store time_series that match this resolution.</li><li><code>time_series_in_memory::Bool=false</code>: Store time series data in memory instead of HDF5 file</li><li><code>time_series_directory=nothing</code>: Store time series data in directory instead of tmpfs</li><li><code>runchecks::Bool=true</code>: Validate struct fields.</li></ul><p>Throws DataFormatError if time_series with multiple resolutions are detected.</p><ul><li>A time_series has a different resolution than others.</li><li>A time_series has a different horizon than others.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/parsers/power_system_table_data.jl#L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.System-Tuple{PowerModelsData}" href="#PowerSystems.System-Tuple{PowerModelsData}"><code>PowerSystems.System</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(pm_data::PowerModelsData; kwargs...) -&gt; Any
</code></pre><p>Constructs a System from PowerModelsData.</p><p><strong>Arguments</strong></p><ul><li><code>pm_data::Union{PowerModelsData, Union{String, IO}}</code>: PowerModels data object or supported</li></ul><p>load flow case (*.m, *.raw)</p><p><strong>Keyword arguments</strong></p><ul><li><code>ext::Dict</code>: Contains user-defined parameters. Should only contain standard types.</li><li><code>runchecks::Bool</code>: Run available checks on input fields and when add_component! is called. Throws InvalidValue if an error is found.</li><li><code>time_series_in_memory::Bool=false</code>: Store time series data in memory instead of HDF5.</li><li><code>config_path::String</code>: specify path to validation config file</li><li><code>pm_data_corrections::Bool=true</code> : Run the PowerModels data corrections (aka :validate in PowerModels)</li><li><code>import_all:Bool=false</code> : Import all fields from PTI files</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">sys = System(
    pm_data, config_path = &quot;ACTIVSg25k_validation.json&quot;,
    bus_name_formatter = x-&gt;string(x[&quot;name&quot;]*&quot;-&quot;*string(x[&quot;index&quot;])),
    load_name_formatter = x-&gt;strip(join(x[&quot;source_id&quot;], &quot;_&quot;))
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/parsers/power_models_data.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.from_json-Tuple{Union{IO, String}, Type{System}}" href="#InfrastructureSystems.from_json-Tuple{Union{IO, String}, Type{System}}"><code>InfrastructureSystems.from_json</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_json(
    io::Union{IO, String},
    ::Type{System};
    runchecks,
    assign_new_uuids,
    kwargs...
) -&gt; System
</code></pre><p>If assign<em>new</em>uuids = true, generate new UUIDs for the system and all components.</p><p>Warning: time series data is not restored by this method. If that is needed, use the normal process to construct the system from a serialized JSON file instead, such as with <code>System(&quot;sys.json&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_name-Tuple{System}" href="#InfrastructureSystems.get_name-Tuple{System}"><code>InfrastructureSystems.get_name</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_name(sys::System) -&gt; Union{Nothing, String}
</code></pre><p>Get the name of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_supplemental_attribute-Tuple{System, Base.UUID}" href="#InfrastructureSystems.get_supplemental_attribute-Tuple{System, Base.UUID}"><code>InfrastructureSystems.get_supplemental_attribute</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_supplemental_attribute(
    sys::System,
    uuid::Base.UUID
) -&gt; SupplementalAttribute
</code></pre><p>Return the supplemental attribute with the given uuid.</p><p>Throws ArgumentError if the attribute is not stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1552">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_supplemental_attributes-Union{Tuple{T}, Tuple{Function, Type{T}, System}} where T&lt;:SupplementalAttribute" href="#InfrastructureSystems.get_supplemental_attributes-Union{Tuple{T}, Tuple{Function, Type{T}, System}} where T&lt;:SupplementalAttribute"><code>InfrastructureSystems.get_supplemental_attributes</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_supplemental_attributes(
    filter_func::Function,
    _::Type{T&lt;:SupplementalAttribute},
    sys::System
) -&gt; InfrastructureSystems.FlattenIteratorWrapper{T, I} where {T&lt;:SupplementalAttribute, I&lt;:(Vector)}
</code></pre><p>Returns an iterator of supplemental attributes. T can be concrete or abstract. Call collect on the result if an array is desired.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">iter = get_supplemental_attributes(GeometricDistributionForcedOutage, sys)
iter = get_supplemental_attributes(Outage, sys)
iter = get_supplemental_attributes(x -&gt; get_mean_time_to_recovery(x) ==  &gt;= 0.5, GeometricDistributionForcedOutage, sys)
outages = get_supplemental_attributes(GeometricDistributionForcedOutage, sys) do outage
    get_mean_time_to_recovery(x) ==  &gt;= 0.5
end
outages = collect(get_supplemental_attributes(GeometricDistributionForcedOutage, sys))</code></pre><p>See also: <a href="#PowerSystems.iterate_supplemental_attributes-Tuple{System}"><code>iterate_supplemental_attributes</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_multiple" href="#InfrastructureSystems.get_time_series_multiple"><code>InfrastructureSystems.get_time_series_multiple</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_time_series_multiple(sys::System; ...) -&gt; Channel{Any}
get_time_series_multiple(
    sys::System,
    filter_func;
    type,
    name
) -&gt; Channel{Any}
</code></pre><p>Return an iterator of time series in order of initial time.</p><p>Note that passing a filter function can be much slower than the other filtering parameters because it reads time series data from media.</p><p>Call <code>collect</code> on the result to get an array.</p><p><strong>Arguments</strong></p><ul><li><code>data::SystemData</code>: system</li><li><code>filter_func = nothing</code>: Only return time series for which this returns true.</li><li><code>type = nothing</code>: Only return time series with this type.</li><li><code>name = nothing</code>: Only return time series matching this value.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">for time_series in get_time_series_multiple(sys)
    @show time_series
end

ts = collect(get_time_series_multiple(sys; type = SingleTimeSeries))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_name!-Tuple{Component, AbstractString}" href="#InfrastructureSystems.set_name!-Tuple{Component, AbstractString}"><code>InfrastructureSystems.set_name!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_name!(
    component::Component,
    name::AbstractString
) -&gt; AbstractString
</code></pre><p>Set the name of a component.</p><p>Throws an exception if the component is attached to a system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L932">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_name!-Tuple{System, AbstractString}" href="#InfrastructureSystems.set_name!-Tuple{System, AbstractString}"><code>InfrastructureSystems.set_name!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_name!(
    sys::System,
    name::AbstractString
) -&gt; AbstractString
</code></pre><p>Set the name of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L508">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.set_name!-Tuple{System, Component, AbstractString}" href="#InfrastructureSystems.set_name!-Tuple{System, Component, AbstractString}"><code>InfrastructureSystems.set_name!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_name!(
    sys::System,
    component::Component,
    name::AbstractString
)
</code></pre><p>Set the name for a component that is attached to the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L926">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.to_json-Tuple{System, AbstractString}" href="#InfrastructureSystems.to_json-Tuple{System, AbstractString}"><code>InfrastructureSystems.to_json</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_json(
    sys::System,
    filename::AbstractString;
    user_data,
    pretty,
    force,
    runchecks
)
</code></pre><p>Serializes a system to a JSON file and saves time series to an HDF5 file.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>filename::AbstractString</code>: filename to write</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>user_data::Union{Nothing, Dict} = nothing</code>: optional metadata to record</li><li><code>pretty::Bool = false</code>: whether to pretty-print the JSON</li><li><code>force::Bool = false</code>: whether to overwrite existing files</li><li><code>check::Bool = false</code>: whether to run system validation checks</li></ul><p>Refer to <a href="#PowerSystems.check_component-Tuple{System, Component}"><code>check_component</code></a> for exceptions thrown if <code>check = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_component!-Tuple{System, DynamicInjection, StaticInjection}" href="#PowerSystems.add_component!-Tuple{System, DynamicInjection, StaticInjection}"><code>PowerSystems.add_component!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_component!(
    sys::System,
    dyn_injector::DynamicInjection,
    static_injector::StaticInjection;
    kwargs...
)
</code></pre><p>Add a dynamic injector to the system.</p><p>Throws ArgumentError if the name does not match the static<em>injector name. Throws ArgumentError if the static</em>injector is not attached to the system.</p><p>All rules for the generic add_component! method also apply.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_component!-Union{Tuple{T}, Tuple{System, T}} where T&lt;:Component" href="#PowerSystems.add_component!-Union{Tuple{T}, Tuple{System, T}} where T&lt;:Component"><code>PowerSystems.add_component!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_component!(
    sys::System,
    component::Component;
    skip_validation,
    kwargs...
)
</code></pre><p>Add a component to the system.</p><p>Throws ArgumentError if the component&#39;s name is already stored for its concrete type. Throws ArgumentError if any Component-specific rule is violated. Throws InvalidValue if any of the component&#39;s field values are outside of defined valid range.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">sys = System(100.0)

# Add a single component.
add_component!(sys, bus)

# Add many at once.
buses = [bus1, bus2, bus3]
generators = [gen1, gen2, gen3]
foreach(x -&gt; add_component!(sys, x), Iterators.flatten((buses, generators)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_components!-Tuple{System, Any}" href="#PowerSystems.add_components!-Tuple{System, Any}"><code>PowerSystems.add_components!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_components!(sys::System, components)
</code></pre><p>Add many components to the system at once.</p><p>Throws ArgumentError if the component&#39;s name is already stored for its concrete type. Throws ArgumentError if any Component-specific rule is violated. Throws InvalidValue if any of the component&#39;s field values are outside of defined valid range.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">sys = System(100.0)

buses = [bus1, bus2, bus3]
generators = [gen1, gen2, gen3]
foreach(x -&gt; add_component!(sys, x), Iterators.flatten((buses, generators)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_service!-Tuple{Device, Service, System}" href="#PowerSystems.add_service!-Tuple{Device, Service, System}"><code>PowerSystems.add_service!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_service!(device::Device, service::Service, sys::System)
</code></pre><p>Similar to <a href="#PowerSystems.add_service!-Tuple{Device, Service, System}"><code>add_service!</code></a> but for Service and Device already stored in the system. Performs validation checks on the device and the system</p><p><strong>Arguments</strong></p><ul><li><code>device::Device</code>: Device</li><li><code>service::Service</code>: Service</li><li><code>sys::System</code>: system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L683">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_service!-Tuple{System, ConstantReserveGroup, Vector{&lt;:Service}}" href="#PowerSystems.add_service!-Tuple{System, ConstantReserveGroup, Vector{&lt;:Service}}"><code>PowerSystems.add_service!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_service!(
    sys::System,
    service::ConstantReserveGroup,
    contributing_services::Vector{&lt;:Service};
    skip_validation,
    kwargs...
)
</code></pre><p>Similar to <a href="#PowerSystems.add_component!-Tuple{System, DynamicInjection, StaticInjection}"><code>add_component!</code></a> but for ConstantReserveGroup.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>service::ConstantReserveGroup</code>: service to add</li><li><code>contributing_services</code>: contributing services to the group</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L736">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_service!-Tuple{System, ConstantReserveGroup}" href="#PowerSystems.add_service!-Tuple{System, ConstantReserveGroup}"><code>PowerSystems.add_service!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_service!(
    sys::System,
    service::ConstantReserveGroup;
    skip_validation,
    kwargs...
)
</code></pre><p>Similar to <a href="#PowerSystems.add_component!-Tuple{System, DynamicInjection, StaticInjection}"><code>add_component!</code></a> but for ConstantReserveGroup.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>service::ConstantReserveGroup</code>: service to add</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_service!-Tuple{System, Service, Any}" href="#PowerSystems.add_service!-Tuple{System, Service, Any}"><code>PowerSystems.add_service!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_service!(
    sys::System,
    service::Service,
    contributing_devices;
    kwargs...
)
</code></pre><p>Similar to <a href="#PowerSystems.add_component!-Tuple{System, DynamicInjection, StaticInjection}"><code>add_component!</code></a> but for services.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>service::Service</code>: service to add</li><li><code>contributing_devices</code>: Must be an iterable of type Device</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_service!-Tuple{System, Service, Device}" href="#PowerSystems.add_service!-Tuple{System, Service, Device}"><code>PowerSystems.add_service!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_service!(
    sys::System,
    service::Service,
    contributing_device::Device;
    kwargs...
)
</code></pre><p>Similar to <a href="#PowerSystems.add_component!-Tuple{System, DynamicInjection, StaticInjection}"><code>add_component!</code></a> but for services.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>service::Service</code>: service to add</li><li><code>contributing_device::Device</code>: Valid Device</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L670">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_supplemental_attribute!-Tuple{System, Component, SupplementalAttribute}" href="#PowerSystems.add_supplemental_attribute!-Tuple{System, Component, SupplementalAttribute}"><code>PowerSystems.add_supplemental_attribute!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_supplemental_attribute!(
    sys::System,
    component::Component,
    attribute::SupplementalAttribute
)
</code></pre><p>Add a supplemental attribute to the component. The attribute may already be attached to a different component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_time_series!-Tuple{System, AbstractString}" href="#PowerSystems.add_time_series!-Tuple{System, AbstractString}"><code>PowerSystems.add_time_series!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_time_series!(
    sys::System,
    metadata_file::AbstractString;
    resolution
) -&gt; Vector{TimeSeriesKey}
</code></pre><p>Add time series data from a metadata file or metadata descriptors.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>metadata_file::AbstractString</code>: metadata file for timeseries that includes an array of IS.TimeSeriesFileMetadata instances or a vector.</li><li><code>resolution::DateTime.Period=nothing</code>: skip time series that don&#39;t match this resolution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L787">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_time_series!-Tuple{System, Any, TimeSeriesData}" href="#PowerSystems.add_time_series!-Tuple{System, Any, TimeSeriesData}"><code>PowerSystems.add_time_series!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_time_series!(
    sys::System,
    components,
    time_series::TimeSeriesData;
    features...
) -&gt; TimeSeriesKey
</code></pre><p>Add the same time series data to multiple components.</p><p>This is significantly more efficent than calling <code>add_time_series!</code> for each component individually with the same data because in this case, only one time series array is stored.</p><p>Throws ArgumentError if a component is not stored in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_time_series!-Tuple{System, Component, TimeSeriesData}" href="#PowerSystems.add_time_series!-Tuple{System, Component, TimeSeriesData}"><code>PowerSystems.add_time_series!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_time_series!(
    sys::System,
    component::Component,
    time_series::TimeSeriesData;
    features...
) -&gt; TimeSeriesKey
</code></pre><p>Add time series data to a component.</p><p>Throws ArgumentError if the component is not stored in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_time_series!-Tuple{System, Vector{InfrastructureSystems.TimeSeriesFileMetadata}}" href="#PowerSystems.add_time_series!-Tuple{System, Vector{InfrastructureSystems.TimeSeriesFileMetadata}}"><code>PowerSystems.add_time_series!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_time_series!(
    sys::System,
    file_metadata::Vector{InfrastructureSystems.TimeSeriesFileMetadata};
    resolution
) -&gt; Vector{TimeSeriesKey}
</code></pre><p>Add time series data from a metadata file or metadata descriptors.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>timeseries_metadata::Vector{IS.TimeSeriesFileMetadata}</code>: metadata for timeseries</li><li><code>resolution::DateTime.Period=nothing</code>: skip time series that don&#39;t match this resolution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L805">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.bulk_add_time_series!-Tuple{System, Any}" href="#PowerSystems.bulk_add_time_series!-Tuple{System, Any}"><code>PowerSystems.bulk_add_time_series!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bulk_add_time_series!(
    sys::System,
    associations;
    batch_size
) -&gt; Vector{TimeSeriesKey}
</code></pre><p>Add many time series in bulk. This method is advantageous when adding thousands of time series arrays because of the overhead in writing the time series to the underlying storage.</p><p><strong>Arguments</strong></p><ul><li><code>sys::System</code>: system</li><li><code>associations</code>: Iterable of TimeSeriesAssociation instances. Using a Vector is not recommended. Pass a Generator or Iterator to avoid loading all time series data into system memory at once.</li><li><code>batch_size::Int</code>: Number of time series to add per batch. Defaults to 100.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">resolution = Dates.Hour(1)
associations = (
    IS.TimeSeriesAssociation(
        gen,
        Deterministic(
            data = read_time_series(get_name(gen) * &quot;.csv&quot;),
            name = &quot;get_max_active_power&quot;,
            resolution=resolution),
    )
    for gen in get_components(ThermalStandard, sys)
)
bulk_add_time_series!(sys, associations)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.check-Tuple{System}" href="#PowerSystems.check-Tuple{System}"><code>PowerSystems.check</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check(sys::System)
</code></pre><p>Check system consistency and validity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.check_component-Tuple{System, Component}" href="#PowerSystems.check_component-Tuple{System, Component}"><code>PowerSystems.check_component</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_component(sys::System, component::Component)
</code></pre><p>Check the values of a component.</p><p>Throws InvalidValue if any of the component&#39;s field values are outside of defined valid range or if the custom validate method for the type fails its check.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1698">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.check_components-Tuple{System, Any}" href="#PowerSystems.check_components-Tuple{System, Any}"><code>PowerSystems.check_components</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_components(sys::System, components)
</code></pre><p>Check the values of each component in an iterable of components. See <a href="#PowerSystems.check_component-Tuple{System, Component}"><code>check_component</code></a> for exceptions thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1688">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.check_components-Tuple{System}" href="#PowerSystems.check_components-Tuple{System}"><code>PowerSystems.check_components</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_components(sys::System; check_masked_components)
</code></pre><p>Check the values of all components. See <a href="#PowerSystems.check_component-Tuple{System, Component}"><code>check_component</code></a> for exceptions thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.check_components-Union{Tuple{T}, Tuple{System, Type{T}}} where T&lt;:Component" href="#PowerSystems.check_components-Union{Tuple{T}, Tuple{System, Type{T}}} where T&lt;:Component"><code>PowerSystems.check_components</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_components(
    sys::System,
    ::Type{T&lt;:Component};
    check_masked_components
)
</code></pre><p>Check the values of components of a given abstract or concrete type. See <a href="#PowerSystems.check_component-Tuple{System, Component}"><code>check_component</code></a> for exceptions thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1668">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.check_time_series_consistency-Union{Tuple{T}, Tuple{System, Type{T}}} where T&lt;:TimeSeriesData" href="#PowerSystems.check_time_series_consistency-Union{Tuple{T}, Tuple{System, Type{T}}} where T&lt;:TimeSeriesData"><code>PowerSystems.check_time_series_consistency</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_time_series_consistency(
    sys::System,
    _::Type{T&lt;:TimeSeriesData}
) -&gt; Union{Nothing, Tuple{Any, Any}}
</code></pre><p>Checks time series in the system for inconsistencies.</p><p>For SingleTimeSeries, returns a Tuple of initial_timestamp and length.</p><p>This is a no-op for subtypes of Forecast because those are already guaranteed to be consistent.</p><p>Throws InfrastructureSystems.InvalidValue if any time series is inconsistent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L2500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.clear_components!-Tuple{System}" href="#PowerSystems.clear_components!-Tuple{System}"><code>PowerSystems.clear_components!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clear_components!(sys::System)
</code></pre><p>Remove all components from the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L889">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.clear_ext!-Tuple{System}" href="#PowerSystems.clear_ext!-Tuple{System}"><code>PowerSystems.clear_ext!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clear_ext!(sys::System)
</code></pre><p>Clear any value stored in ext.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.clear_time_series!-Tuple{System}" href="#PowerSystems.clear_time_series!-Tuple{System}"><code>PowerSystems.clear_time_series!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clear_time_series!(sys::System)
</code></pre><p>Remove all time series data from the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.convert_component!-Tuple{System, Line, Type{MonitoredLine}}" href="#PowerSystems.convert_component!-Tuple{System, Line, Type{MonitoredLine}}"><code>PowerSystems.convert_component!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert_component!(
    sys::System,
    line::Line,
    linetype::Type{MonitoredLine};
    kwargs...
)
</code></pre><p>Converts a Line component to a MonitoredLine component and replaces the original in the system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L2344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.convert_component!-Tuple{System, MonitoredLine, Type{Line}}" href="#PowerSystems.convert_component!-Tuple{System, MonitoredLine, Type{Line}}"><code>PowerSystems.convert_component!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert_component!(
    sys::System,
    line::MonitoredLine,
    linetype::Type{Line};
    kwargs...
)
</code></pre><p>Converts a MonitoredLine component to a Line component and replaces the original in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L2379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.convert_component!-Tuple{System, PowerLoad, Type{StandardLoad}}" href="#PowerSystems.convert_component!-Tuple{System, PowerLoad, Type{StandardLoad}}"><code>PowerSystems.convert_component!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert_component!(
    sys::System,
    old_load::PowerLoad,
    new_type::Type{StandardLoad};
    kwargs...
)
</code></pre><p>Converts a PowerLoad component to a StandardLoad component and replaces the original in the system. Does not set any fields in StandardLoad that lack a PowerLoad equivalent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L2422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.filter_components_by_subsystem!-Tuple{System, AbstractString}" href="#PowerSystems.filter_components_by_subsystem!-Tuple{System, AbstractString}"><code>PowerSystems.filter_components_by_subsystem!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_components_by_subsystem!(
    sys::System,
    subsystem::AbstractString;
    runchecks
)
</code></pre><p>Filter out all components that are not part of the subsystem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.from_subsystem-Tuple{System, AbstractString}" href="#PowerSystems.from_subsystem-Tuple{System, AbstractString}"><code>PowerSystems.from_subsystem</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_subsystem(
    sys::System,
    subsystem::AbstractString;
    runchecks
) -&gt; System
</code></pre><p>Construct a System from a subsystem of an existing system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_aggregation_topology_mapping-Union{Tuple{T}, Tuple{Type{T}, System}} where T&lt;:AggregationTopology" href="#PowerSystems.get_aggregation_topology_mapping-Union{Tuple{T}, Tuple{Type{T}, System}} where T&lt;:AggregationTopology"><code>PowerSystems.get_aggregation_topology_mapping</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_aggregation_topology_mapping(
    _::Type{T&lt;:AggregationTopology},
    sys::System
) -&gt; Dict{String, Vector{ACBus}}
</code></pre><p>Return a mapping of AggregationTopology name to vector of buses within it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_base_power-Tuple{System}" href="#PowerSystems.get_base_power-Tuple{System}"><code>PowerSystems.get_base_power</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_base_power(sys::System) -&gt; Float64
</code></pre><p>Return the system&#39;s base power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_bus-Tuple{System, AbstractString}" href="#PowerSystems.get_bus-Tuple{System, AbstractString}"><code>PowerSystems.get_bus</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_bus(
    sys::System,
    name::AbstractString
) -&gt; Union{Nothing, InfrastructureSystems.InfrastructureSystemsComponent}
</code></pre><p>Return bus with name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1939">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_bus-Tuple{System, Int64}" href="#PowerSystems.get_bus-Tuple{System, Int64}"><code>PowerSystems.get_bus</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_bus(sys::System, bus_number::Int64) -&gt; Any
</code></pre><p>Return bus with bus_number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1946">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_bus_numbers-Tuple{System}" href="#PowerSystems.get_bus_numbers-Tuple{System}"><code>PowerSystems.get_bus_numbers</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_bus_numbers(sys::System) -&gt; Vector{Int64}
</code></pre><p>Return a sorted vector of bus numbers in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L2257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_buses-Tuple{System, AggregationTopology}" href="#PowerSystems.get_buses-Tuple{System, AggregationTopology}"><code>PowerSystems.get_buses</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_buses(
    sys::System,
    aggregator::AggregationTopology
) -&gt; Vector{ACBus}
</code></pre><p>Return a vector of buses contained within the AggregationTopology.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_buses-Tuple{System, Set{Int64}}" href="#PowerSystems.get_buses-Tuple{System, Set{Int64}}"><code>PowerSystems.get_buses</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_buses(
    sys::System,
    bus_numbers::Set{Int64}
) -&gt; Vector{ACBus}
</code></pre><p>Return all buses values with bus_numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1959">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_component-Tuple{System, Base.UUID}" href="#PowerSystems.get_component-Tuple{System, Base.UUID}"><code>PowerSystems.get_component</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_component(
    sys::System,
    uuid::Base.UUID
) -&gt; InfrastructureSystems.InfrastructureSystemsComponent
</code></pre><p>Get the component by UUID.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1075">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_component-Union{Tuple{T}, Tuple{Type{T}, System, AbstractString}} where T&lt;:Component" href="#PowerSystems.get_component-Union{Tuple{T}, Tuple{Type{T}, System, AbstractString}} where T&lt;:Component"><code>PowerSystems.get_component</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_component(
    _::Type{T&lt;:Component},
    sys::System,
    name::AbstractString
) -&gt; Union{Nothing, InfrastructureSystems.InfrastructureSystemsComponent}
</code></pre><p>Get the component of type T with name. Returns nothing if no component matches. If T is an abstract type then the names of components across all subtypes of T must be unique.</p><p>See <a href="#PowerSystems.get_components_by_name-Union{Tuple{T}, Tuple{Type{T}, System, AbstractString}} where T&lt;:Component"><code>get_components_by_name</code></a> for abstract types with non-unique names across subtypes.</p><p>Throws ArgumentError if T is not a concrete type and there is more than one component with     requested name</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1020">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_components-Tuple{System, SupplementalAttribute}" href="#PowerSystems.get_components-Tuple{System, SupplementalAttribute}"><code>PowerSystems.get_components</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_components(
    sys::System,
    attribute::SupplementalAttribute
) -&gt; Any
</code></pre><p>Return a vector of components that are attached to the supplemental attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1068">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_components-Union{Tuple{T}, Tuple{Type{T}, System}} where T&lt;:Component" href="#PowerSystems.get_components-Union{Tuple{T}, Tuple{Type{T}, System}} where T&lt;:Component"><code>PowerSystems.get_components</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_components(
    ::Type{T&lt;:Component},
    sys::System;
    subsystem_name
) -&gt; InfrastructureSystems.FlattenIteratorWrapper{T, I} where {T&lt;:Component, I&lt;:(Vector)}
</code></pre><p>Returns an iterator of components. T can be concrete or abstract. Call collect on the result if an array is desired.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">iter = PowerSystems.get_components(ThermalStandard, sys)
iter = PowerSystems.get_components(Generator, sys)
iter = PowerSystems.get_components(x -&gt; PowerSystems.get_available(x), Generator, sys)
thermal_gens = get_components(ThermalStandard, sys) do gen
    get_available(gen)
end
generators = collect(PowerSystems.get_components(Generator, sys))
</code></pre><p>See also: <a href="#PowerSystems.iterate_components-Tuple{System}"><code>iterate_components</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1033">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_components_by_name-Union{Tuple{T}, Tuple{Type{T}, System, AbstractString}} where T&lt;:Component" href="#PowerSystems.get_components_by_name-Union{Tuple{T}, Tuple{Type{T}, System, AbstractString}} where T&lt;:Component"><code>PowerSystems.get_components_by_name</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_components_by_name(
    _::Type{T&lt;:Component},
    sys::System,
    name::AbstractString
) -&gt; Vector{T} where T&lt;:InfrastructureSystems.InfrastructureSystemsComponent
</code></pre><p>Get the components of abstract type T with name. Note that PowerSystems enforces unique names on each concrete type but not across concrete types.</p><p>See <a href="#PowerSystems.get_component-Tuple{System, Base.UUID}"><code>get_component</code></a> if the concrete type is known.</p><p>Throws ArgumentError if T is not an abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1098">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_components_in_aggregation_topology-Union{Tuple{T}, Tuple{Type{T}, System, AggregationTopology}} where T&lt;:StaticInjection" href="#PowerSystems.get_components_in_aggregation_topology-Union{Tuple{T}, Tuple{Type{T}, System, AggregationTopology}} where T&lt;:StaticInjection"><code>PowerSystems.get_components_in_aggregation_topology</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_components_in_aggregation_topology(
    _::Type{T&lt;:StaticInjection},
    sys::System,
    aggregator::AggregationTopology
) -&gt; Vector{T} where T&lt;:StaticInjection
</code></pre><p>Return a vector of components with buses in the AggregationTopology.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_compression_settings-Tuple{System}" href="#PowerSystems.get_compression_settings-Tuple{System}"><code>PowerSystems.get_compression_settings</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_compression_settings(sys::System) -&gt; CompressionSettings
</code></pre><p>Return the compression settings used for system data such as time series arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_contributing_device_mapping-Tuple{System}" href="#PowerSystems.get_contributing_device_mapping-Tuple{System}"><code>PowerSystems.get_contributing_device_mapping</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_contributing_device_mapping(
    sys::System
) -&gt; Dict{@NamedTuple{type::DataType, name::String}, ServiceContributingDevices}
</code></pre><p>Return an instance of ServiceContributingDevicesMapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_contributing_devices-Union{Tuple{T}, Tuple{System, T}} where T&lt;:Service" href="#PowerSystems.get_contributing_devices-Union{Tuple{T}, Tuple{System, T}} where T&lt;:Service"><code>PowerSystems.get_contributing_devices</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_contributing_devices(
    sys::System,
    service::Service
) -&gt; Vector
</code></pre><p>Return a vector of devices contributing to the service.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_description-Tuple{System}" href="#PowerSystems.get_description-Tuple{System}"><code>PowerSystems.get_description</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_description(sys::System) -&gt; Union{Nothing, String}
</code></pre><p>Get the description of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_existing_component_types-Tuple{System}" href="#PowerSystems.get_existing_component_types-Tuple{System}"><code>PowerSystems.get_existing_component_types</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_existing_component_types(
    sys::System
) -&gt; Vector{DataType}
</code></pre><p>Return all the component types in the system. It does not return masked components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1986">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_existing_device_types-Tuple{System}" href="#PowerSystems.get_existing_device_types-Tuple{System}"><code>PowerSystems.get_existing_device_types</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_existing_device_types(sys::System) -&gt; Vector{DataType}
</code></pre><p>Return all the device types in the system. It does not return component types or masked components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1973">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_ext-Tuple{System}" href="#PowerSystems.get_ext-Tuple{System}"><code>PowerSystems.get_ext</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_ext(sys::System) -&gt; Union{Nothing, Dict{String, Any}}
</code></pre><p>Return a user-modifiable dictionary to store extra information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_forecast_horizon-Tuple{System}" href="#PowerSystems.get_forecast_horizon-Tuple{System}"><code>PowerSystems.get_forecast_horizon</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_forecast_horizon(sys::System) -&gt; Any
</code></pre><p>Return the horizon for all forecasts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_forecast_initial_times-Tuple{System}" href="#PowerSystems.get_forecast_initial_times-Tuple{System}"><code>PowerSystems.get_forecast_initial_times</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_forecast_initial_times(sys::System) -&gt; Any
</code></pre><p>Return the initial times for all forecasts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_forecast_initial_timestamp-Tuple{System}" href="#PowerSystems.get_forecast_initial_timestamp-Tuple{System}"><code>PowerSystems.get_forecast_initial_timestamp</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_forecast_initial_timestamp(sys::System) -&gt; Any
</code></pre><p>Return the initial_timestamp for all forecasts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_forecast_interval-Tuple{System}" href="#PowerSystems.get_forecast_interval-Tuple{System}"><code>PowerSystems.get_forecast_interval</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_forecast_interval(sys::System) -&gt; Any
</code></pre><p>Return the interval for all forecasts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_forecast_window_count-Tuple{System}" href="#PowerSystems.get_forecast_window_count-Tuple{System}"><code>PowerSystems.get_forecast_window_count</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_forecast_window_count(sys::System) -&gt; Any
</code></pre><p>Return the window count for all forecasts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_frequency-Tuple{System}" href="#PowerSystems.get_frequency-Tuple{System}"><code>PowerSystems.get_frequency</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_frequency(sys::System) -&gt; Float64
</code></pre><p>Return the system&#39;s frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_runchecks-Tuple{System}" href="#PowerSystems.get_runchecks-Tuple{System}"><code>PowerSystems.get_runchecks</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_runchecks(sys::System) -&gt; Bool
</code></pre><p>Return true if checks are enabled on the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_time_series_counts-Tuple{System}" href="#PowerSystems.get_time_series_counts-Tuple{System}"><code>PowerSystems.get_time_series_counts</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_time_series_counts(sys::System) -&gt; TimeSeriesCounts
</code></pre><p>Returns counts of time series including attachments to components and supplemental attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L2494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_time_series_resolutions-Tuple{System}" href="#PowerSystems.get_time_series_resolutions-Tuple{System}"><code>PowerSystems.get_time_series_resolutions</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_time_series_resolutions(
    sys::System;
    time_series_type
) -&gt; Any
</code></pre><p>Return a sorted Vector of distinct resolutions for all time series of the given type (or all types).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.has_component-Tuple{System, Type{&lt;:Component}, AbstractString}" href="#PowerSystems.has_component-Tuple{System, Type{&lt;:Component}, AbstractString}"><code>PowerSystems.has_component</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_component(
    sys::System,
    T::Type{&lt;:Component},
    name::AbstractString
) -&gt; Bool
</code></pre><p>Check to see if the component of type T with name exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1010">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.has_component-Tuple{System, Type{&lt;:Component}}" href="#PowerSystems.has_component-Tuple{System, Type{&lt;:Component}}"><code>PowerSystems.has_component</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_component(sys::System, T::Type{&lt;:Component})
</code></pre><p>Check to see if the component of type T exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1003">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.is_component_in_aggregation_topology-Union{Tuple{T}, Tuple{Component, T}} where T&lt;:AggregationTopology" href="#PowerSystems.is_component_in_aggregation_topology-Union{Tuple{T}, Tuple{Component, T}} where T&lt;:AggregationTopology"><code>PowerSystems.is_component_in_aggregation_topology</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_component_in_aggregation_topology(
    comp::Component,
    aggregator::AggregationTopology
) -&gt; Union{Missing, Bool}
</code></pre><p>Return whether the given component&#39;s bus is in the AggregationTopology.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.iterate_components-Tuple{System}" href="#PowerSystems.iterate_components-Tuple{System}"><code>PowerSystems.iterate_components</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iterate_components(
    sys::System
) -&gt; Base.Iterators.Flatten{Base.Generator{Base.ValueIterator{Dict{DataType, Dict{String, &lt;:InfrastructureSystems.InfrastructureSystemsComponent}}}, InfrastructureSystems.var&quot;#112#113&quot;}}
</code></pre><p>Iterates over all components.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">for component in iterate_components(sys)
    @show component
end</code></pre><p>See also: <a href="#PowerSystems.get_components-Tuple{System, SupplementalAttribute}"><code>get_components</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L873">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.iterate_supplemental_attributes-Tuple{System}" href="#PowerSystems.iterate_supplemental_attributes-Tuple{System}"><code>PowerSystems.iterate_supplemental_attributes</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iterate_supplemental_attributes(
    sys::System
) -&gt; Base.Iterators.Flatten{Base.Generator{Base.ValueIterator{Dict{DataType, Dict{Base.UUID, &lt;:SupplementalAttribute}}}, InfrastructureSystems.var&quot;#112#113&quot;}}
</code></pre><p>Iterates over all supplemental_attributes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">for supplemental_attribute in iterate_supplemental_attributes(sys)
    @show supplemental_attribute
end</code></pre><p>See also: <a href="#InfrastructureSystems.get_supplemental_attributes-Union{Tuple{T}, Tuple{Function, Type{T}, System}} where T&lt;:SupplementalAttribute"><code>get_supplemental_attributes</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.open_time_series_store!" href="#PowerSystems.open_time_series_store!"><code>PowerSystems.open_time_series_store!</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">open_time_series_store!(
    func::Function,
    sys::System;
    ...
) -&gt; Any
open_time_series_store!(
    func::Function,
    sys::System,
    mode,
    args...;
    kwargs...
) -&gt; Any
</code></pre><p>Open the time series store for bulk additions or reads. This is recommended before calling add<em>time</em>series! many times because of the overhead associated with opening and closing an HDF5 file.</p><p>This is not necessary for an in-memory time series store.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Assume there is a system with an array of components and SingleTimeSeries
open_time_series_store!(sys, &quot;r+&quot;) do
    for (component, ts) in zip(components, single_time_series)
        add_time_series!(sys, component, ts)
    end
end</code></pre><p>julia&gt;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L759">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.remove_component!-Union{Tuple{T}, Tuple{System, T}} where T&lt;:Component" href="#PowerSystems.remove_component!-Union{Tuple{T}, Tuple{System, T}} where T&lt;:Component"><code>PowerSystems.remove_component!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_component!(sys::System, component::Component)
</code></pre><p>Remove a component from the system by its value.</p><p>Throws ArgumentError if the component is not stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L956">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.remove_component!-Union{Tuple{T}, Tuple{Type{T}, System, AbstractString}} where T&lt;:Component" href="#PowerSystems.remove_component!-Union{Tuple{T}, Tuple{Type{T}, System, AbstractString}} where T&lt;:Component"><code>PowerSystems.remove_component!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_component!(
    _::Type{T&lt;:Component},
    sys::System,
    name::AbstractString
)
</code></pre><p>Remove a component from the system by its name.</p><p>Throws ArgumentError if the component is not stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L988">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.remove_supplemental_attribute!-Tuple{System, Component, SupplementalAttribute}" href="#PowerSystems.remove_supplemental_attribute!-Tuple{System, Component, SupplementalAttribute}"><code>PowerSystems.remove_supplemental_attribute!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_supplemental_attribute!(
    sys::System,
    component::Component,
    attribute::SupplementalAttribute
)
</code></pre><p>Remove the supplemental attribute from the component. The attribute will be removed from the system if it is not attached to any other component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.remove_supplemental_attribute!-Tuple{System, SupplementalAttribute}" href="#PowerSystems.remove_supplemental_attribute!-Tuple{System, SupplementalAttribute}"><code>PowerSystems.remove_supplemental_attribute!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_supplemental_attribute!(
    sys::System,
    attribute::SupplementalAttribute
)
</code></pre><p>Remove the supplemental attribute from the system and all attached components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.remove_supplemental_attributes!-Union{Tuple{T}, Tuple{Type{T}, System}} where T&lt;:SupplementalAttribute" href="#PowerSystems.remove_supplemental_attributes!-Union{Tuple{T}, Tuple{Type{T}, System}} where T&lt;:SupplementalAttribute"><code>PowerSystems.remove_supplemental_attributes!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_supplemental_attributes!(
    _::Type{T&lt;:SupplementalAttribute},
    sys::System
)
</code></pre><p>Remove all supplemental attributes with the given type from the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.remove_time_series!-Union{Tuple{T}, Tuple{System, Type{T}, Component, String}} where T&lt;:TimeSeriesData" href="#PowerSystems.remove_time_series!-Union{Tuple{T}, Tuple{System, Type{T}, Component, String}} where T&lt;:TimeSeriesData"><code>PowerSystems.remove_time_series!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_time_series!(
    sys::System,
    _::Type{T&lt;:TimeSeriesData},
    component::Component,
    name::String
)
</code></pre><p>Remove the time series data for a component and time series type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.remove_time_series!-Union{Tuple{T}, Tuple{System, Type{T}}} where T&lt;:TimeSeriesData" href="#PowerSystems.remove_time_series!-Union{Tuple{T}, Tuple{System, Type{T}}} where T&lt;:TimeSeriesData"><code>PowerSystems.remove_time_series!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_time_series!(sys::System, _::Type{T&lt;:TimeSeriesData})
</code></pre><p>Remove all the time series data for a time series type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.sanitize_component!-Tuple{Component, System}" href="#PowerSystems.sanitize_component!-Tuple{Component, System}"><code>PowerSystems.sanitize_component!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sanitize_component!(component::Component, sys::System)
</code></pre><p>Sanitize component values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_contributing_services!-Tuple{System, ConstantReserveGroup, Vector{&lt;:Service}}" href="#PowerSystems.set_contributing_services!-Tuple{System, ConstantReserveGroup, Vector{&lt;:Service}}"><code>PowerSystems.set_contributing_services!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_contributing_services!(
    sys::System,
    service::ConstantReserveGroup,
    val::Vector{&lt;:Service}
)
</code></pre><p>Set ConstantReserveGroup contributing_services with check</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_description!-Tuple{System, AbstractString}" href="#PowerSystems.set_description!-Tuple{System, AbstractString}"><code>PowerSystems.set_description!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_description!(
    sys::System,
    description::AbstractString
) -&gt; AbstractString
</code></pre><p>Set the description of the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_runchecks!-Tuple{System, Bool}" href="#PowerSystems.set_runchecks!-Tuple{System, Bool}"><code>PowerSystems.set_runchecks!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_runchecks!(sys::System, value::Bool)
</code></pre><p>Enable or disable system checks. Applies to component addition as well as overall system consistency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L463">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.set_units_base_system!-Tuple{System, String}" href="#PowerSystems.set_units_base_system!-Tuple{System, String}"><code>PowerSystems.set_units_base_system!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_units_base_system!(system::System, settings::String)
</code></pre><p>Sets the units base for the getter functions on the devices. It modifies the behavior of all getter functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.transform_single_time_series!-Tuple{System, Dates.Period, Dates.Period}" href="#PowerSystems.transform_single_time_series!-Tuple{System, Dates.Period, Dates.Period}"><code>PowerSystems.transform_single_time_series!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform_single_time_series!(
    sys::System,
    horizon::Dates.Period,
    interval::Dates.Period
)
</code></pre><p>Transform all instances of SingleTimeSeries to DeterministicSingleTimeSeries. If all SingleTimeSeries instances cannot be transformed then none will be.</p><p>Any existing DeterministicSingleTimeSeries forecasts will be deleted even if the inputs are invalid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.validate_component-Tuple{Component}" href="#PowerSystems.validate_component-Tuple{Component}"><code>PowerSystems.validate_component</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_component(component::Component) -&gt; Bool
</code></pre><p>Validate the component fields using only those fields. Refer to <a href="#PowerSystems.validate_component_with_system-Tuple{Component, System}"><code>validate_component_with_system</code></a> to use other System data for the validation.</p><p>Return true if the instance is valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1582">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.validate_component_with_system-Tuple{Component, System}" href="#PowerSystems.validate_component_with_system-Tuple{Component, System}"><code>PowerSystems.validate_component_with_system</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_component_with_system(
    component::Component,
    sys::System
) -&gt; Bool
</code></pre><p>Validate a component against System data. Return true if the instance is valid.</p><p>Refer to <a href="#PowerSystems.validate_component-Tuple{Component}"><code>validate_component</code></a> if the validation logic only requires data contained within the instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/base.jl#L1591">source</a></section></article><h2 id="Additional-Component-Methods"><a class="docs-heading-anchor" href="#Additional-Component-Methods">Additional Component Methods</a><a id="Additional-Component-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Component-Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_max_active_power-Tuple{T} where T&lt;:Device" href="#PowerSystems.get_max_active_power-Tuple{T} where T&lt;:Device"><code>PowerSystems.get_max_active_power</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_max_active_power(d::Device) -&gt; Any
</code></pre><p>Return the max active power for a device from get<em>active</em>power_limits.max</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/supplemental_accessors.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_max_reactive_power-Tuple{RenewableDispatch}" href="#PowerSystems.get_max_reactive_power-Tuple{RenewableDispatch}"><code>PowerSystems.get_max_reactive_power</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_max_reactive_power(d::RenewableDispatch) -&gt; Any
</code></pre><p>Return the max reactive power for the Renewable Generation calculated as the rating * power<em>factor if reactive</em>power_limits is nothing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/supplemental_accessors.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.get_max_reactive_power-Tuple{T} where T&lt;:Device" href="#PowerSystems.get_max_reactive_power-Tuple{T} where T&lt;:Device"><code>PowerSystems.get_max_reactive_power</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_max_reactive_power(d::Device) -&gt; Any
</code></pre><p>Return the max reactive power for a device from get<em>reactive</em>power_limits.max</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/models/supplemental_accessors.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series" href="#InfrastructureSystems.get_time_series"><code>InfrastructureSystems.get_time_series</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_time_series(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    key::TimeSeriesKey
) -&gt; Any
get_time_series(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    key::TimeSeriesKey,
    start_time::Union{Nothing, Dates.DateTime}
) -&gt; Any
get_time_series(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    key::TimeSeriesKey,
    start_time::Union{Nothing, Dates.DateTime},
    len::Union{Nothing, Int64}
) -&gt; Any
get_time_series(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    key::TimeSeriesKey,
    start_time::Union{Nothing, Dates.DateTime},
    len::Union{Nothing, Int64},
    count::Union{Nothing, Int64}
) -&gt; Any
</code></pre><p>Return the exact stored data in a time series, using a time series key look up</p><p>This will load all forecast windows into memory by default. Be aware of how much data is stored.</p><p>Specify start_time and len if you only need a subset of data.</p><p>Does not apply a scaling factor multiplier.</p><p><strong>Arguments</strong></p><ul><li><code>owner::TimeSeriesOwners</code>: Component or attribute containing the time series</li><li><code>key::TimeSeriesKey</code>: the time series&#39; key</li><li><code>start_time::Union{Nothing, Dates.DateTime} = nothing</code>: If nothing, use the <code>initial_timestamp</code> of the time series. If the time series is a subtype of Forecast then <code>start_time</code> must be the first timestamp of a window.</li><li><code>len::Union{Nothing, Int} = nothing</code>: Length in the time dimension. If nothing, use the entire length.</li><li><code>count::Union{Nothing, Int} = nothing</code>: Only applicable to subtypes of Forecast. Number of forecast windows starting at <code>start_time</code> to return. Defaults to all available.</li><li><code>features...</code>: User-defined tags that differentiate multiple time series arrays for the same component attribute, such as different arrays for different scenarios or years</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData" href="#InfrastructureSystems.get_time_series-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData"><code>InfrastructureSystems.get_time_series</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_time_series(
    ::Type{T&lt;:TimeSeriesData},
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    name::AbstractString;
    start_time,
    len,
    count,
    features...
) -&gt; Any
</code></pre><p>Return the exact stored data in a time series</p><p>This will load all forecast windows into memory by default. Be aware of how much data is stored.</p><p>Specify <code>start_time</code> and <code>len</code> if you only need a subset of data.</p><p>Does not apply a scaling factor multiplier.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: Concrete subtype of <code>TimeSeriesData</code> to return</li><li><code>owner::TimeSeriesOwners</code>: Component or attribute containing the time series</li><li><code>name::AbstractString</code>: name of time series</li><li><code>start_time::Union{Nothing, Dates.DateTime} = nothing</code>: If nothing, use the <code>initial_timestamp</code> of the time series. If T is a subtype of Forecast then <code>start_time</code> must be the first timestamp of a window.</li><li><code>len::Union{Nothing, Int} = nothing</code>: Length in the time dimension. If nothing, use the entire length.</li><li><code>count::Union{Nothing, Int} = nothing</code>: Only applicable to subtypes of Forecast. Number of forecast windows starting at <code>start_time</code> to return. Defaults to all available.</li><li><code>features...</code>: User-defined tags that differentiate multiple time series arrays for the same component attribute, such as different arrays for different scenarios or years</li></ul><p>See also: <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a>, <a href="#InfrastructureSystems.get_time_series_values"><code>get_time_series_values</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_array" href="#InfrastructureSystems.get_time_series_array"><code>InfrastructureSystems.get_time_series_array</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_time_series_array(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    time_series::StaticTimeSeries;
    ...
) -&gt; Any
get_time_series_array(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    time_series::StaticTimeSeries,
    start_time::Union{Nothing, Dates.DateTime};
    len,
    ignore_scaling_factors
) -&gt; Any
</code></pre><p>Return a <code>TimeSeries.TimeArray</code> from a cached <code>StaticTimeSeries</code> instance.</p><p>If the time series data are scaling factors, the returned data will be scaled by the scaling factor multiplier by default.</p><p><strong>Arguments</strong></p><ul><li><code>owner::TimeSeriesOwners</code>: Component or attribute containing the time series</li><li><code>time_series::StaticTimeSeries</code>: subtype of <code>StaticTimeSeries</code> (e.g., <code>SingleTimeSeries</code>)</li><li><code>start_time::Union{Nothing, Dates.DateTime} = nothing</code>: the first timestamp to retrieve. If nothing, use the <code>initial_timestamp</code> of the time series.</li><li><code>len::Union{Nothing, Int} = nothing</code>: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length</li><li><code>ignore_scaling_factors = false</code>: If <code>true</code>, the time-series data will be multiplied by the result of calling the stored <code>scaling_factor_multiplier</code> function on the <code>owner</code></li></ul><p>See also: <a href="#InfrastructureSystems.get_time_series_values"><code>get_time_series_values</code></a>, <a href="#InfrastructureSystems.get_time_series_timestamps"><code>get_time_series_timestamps</code></a>, <a href="api/@ref"><code>StaticTimeSeriesCache</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_array-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, Forecast, Dates.DateTime}" href="#InfrastructureSystems.get_time_series_array-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, Forecast, Dates.DateTime}"><code>InfrastructureSystems.get_time_series_array</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_time_series_array(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    forecast::Forecast,
    start_time::Dates.DateTime;
    len,
    ignore_scaling_factors
) -&gt; Any
</code></pre><p>Return a <code>TimeSeries.TimeArray</code> for one forecast window from a cached <a href="#InfrastructureSystems.Forecast"><code>Forecast</code></a> instance</p><p>If the time series data are scaling factors, the returned data will be scaled by the scaling factor multiplier by default.</p><p><strong>Arguments</strong></p><ul><li><code>owner::TimeSeriesOwners</code>: Component or attribute containing the time series</li><li><code>forecast::Forecast</code>: a concrete subtype of <a href="#InfrastructureSystems.Forecast"><code>Forecast</code></a></li><li><code>start_time::Union{Nothing, Dates.DateTime} = nothing</code>: the first timestamp of one of the forecast windows</li><li><code>len::Union{Nothing, Int} = nothing</code>: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.</li><li><code>ignore_scaling_factors = false</code>: If <code>true</code>, the time-series data will be multiplied by the result of calling the stored <code>scaling_factor_multiplier</code> function on the <code>owner</code></li></ul><p>See also <a href="#InfrastructureSystems.get_time_series_values-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, Forecast, Dates.DateTime}"><code>get_time_series_values</code></a>, <a href="#InfrastructureSystems.get_time_series_timestamps"><code>get_time_series_timestamps</code></a>, <a href="api/@ref"><code>ForecastCache</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_array-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData" href="#InfrastructureSystems.get_time_series_array-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData"><code>InfrastructureSystems.get_time_series_array</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_time_series_array(
    ::Type{T&lt;:TimeSeriesData},
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    name::AbstractString;
    start_time,
    len,
    ignore_scaling_factors,
    features...
) -&gt; Any
</code></pre><p>Return a <code>TimeSeries.TimeArray</code> from storage for the given time series parameters.</p><p>If the time series data are scaling factors, the returned data will be scaled by the scaling factor multiplier by default.</p><p>This will load all forecast windows into memory by default. Be aware of how much data is stored.</p><p>Specify <code>start_time</code> and <code>len</code> if you only need a subset of data.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: the type of time series (a concrete subtype of <code>TimeSeriesData</code>)</li><li><code>owner::TimeSeriesOwners</code>: Component or attribute containing the time series</li><li><code>name::AbstractString</code>: name of time series</li><li><code>start_time::Union{Nothing, Dates.DateTime} = nothing</code>: If nothing, use the <code>initial_timestamp</code> of the time series. If T is a subtype of <a href="#InfrastructureSystems.Forecast"><code>Forecast</code></a> then <code>start_time</code> must be the first timestamp of a window.</li><li><code>len::Union{Nothing, Int} = nothing</code>: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.</li><li><code>ignore_scaling_factors = false</code>: If <code>true</code>, the time-series data will be multiplied by the result of calling the stored <code>scaling_factor_multiplier</code> function on the <code>owner</code></li><li><code>features...</code>: User-defined tags that differentiate multiple time series arrays for the same component attribute, such as different arrays for different scenarios or years</li></ul><p>See also: <a href="#InfrastructureSystems.get_time_series_values-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData"><code>get_time_series_values</code></a>, <a href="#InfrastructureSystems.get_time_series_timestamps-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData"><code>get_time_series_timestamps</code></a>,  <a href="#InfrastructureSystems.get_time_series"><code>get_time_series</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_keys-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}}" href="#InfrastructureSystems.get_time_series_keys-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}}"><code>InfrastructureSystems.get_time_series_keys</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_time_series_keys(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}
) -&gt; Vector
</code></pre><p>Return information about each time series array attached to the owner. This information can be used to call <a href="#InfrastructureSystems.get_time_series"><code>get_time_series(::TimeSeriesOwners, ::TimeSeriesKey)</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_timestamps" href="#InfrastructureSystems.get_time_series_timestamps"><code>InfrastructureSystems.get_time_series_timestamps</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_time_series_timestamps(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    time_series::StaticTimeSeries;
    ...
) -&gt; Vector{D} where D&lt;:Dates.TimeType
get_time_series_timestamps(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    time_series::StaticTimeSeries,
    start_time::Union{Nothing, Dates.DateTime};
    len
) -&gt; Vector{D} where D&lt;:Dates.TimeType
</code></pre><p>Return a vector of timestamps from a cached StaticTimeSeries instance.</p><p><strong>Arguments</strong></p><ul><li><code>owner::TimeSeriesOwners</code>: Component or attribute containing the time series</li><li><code>time_series::StaticTimeSeries</code>: subtype of <code>StaticTimeSeries</code> (e.g., <code>SingleTimeSeries</code>)</li><li><code>start_time::Union{Nothing, Dates.DateTime} = nothing</code>: the first timestamp to retrieve. If nothing, use the <code>initial_timestamp</code> of the time series.</li><li><code>len::Union{Nothing, Int} = nothing</code>: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length</li></ul><p>See also: <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a>, <a href="#InfrastructureSystems.get_time_series_values"><code>get_time_series_values</code></a>, <a href="api/@ref"><code>StaticTimeSeriesCache</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_timestamps" href="#InfrastructureSystems.get_time_series_timestamps"><code>InfrastructureSystems.get_time_series_timestamps</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_time_series_timestamps(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    forecast::Forecast;
    ...
)
get_time_series_timestamps(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    forecast::Forecast,
    start_time::Union{Nothing, Dates.DateTime};
    len
) -&gt; Vector{D} where D&lt;:Dates.TimeType
</code></pre><p>Return a vector of timestamps from a cached Forecast instance.</p><p><strong>Arguments</strong></p><ul><li><code>owner::TimeSeriesOwners</code>: Component or attribute containing the time series</li><li><code>forecast::Forecast</code>: a concrete subtype of <a href="#InfrastructureSystems.Forecast"><code>Forecast</code></a></li><li><code>start_time::Union{Nothing, Dates.DateTime} = nothing</code>: the first timestamp of one of the forecast windows</li><li><code>len::Union{Nothing, Int} = nothing</code>: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.</li></ul><p>See also: <a href="#InfrastructureSystems.get_time_series_array-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, Forecast, Dates.DateTime}"><code>get_time_series_array</code></a>, <a href="#InfrastructureSystems.get_time_series_values-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, Forecast, Dates.DateTime}"><code>get_time_series_values</code></a>, <a href="api/@ref"><code>ForecastCache</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_timestamps-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData" href="#InfrastructureSystems.get_time_series_timestamps-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData"><code>InfrastructureSystems.get_time_series_timestamps</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_time_series_timestamps(
    ::Type{T&lt;:TimeSeriesData},
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    name::AbstractString;
    start_time,
    len,
    features...
) -&gt; Vector{D} where D&lt;:Dates.TimeType
</code></pre><p>Return a vector of timestamps from storage for the given time series parameters.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: the type of time series (a concrete subtype of <code>TimeSeriesData</code>)</li><li><code>owner::TimeSeriesOwners</code>: Component or attribute containing the time series</li><li><code>name::AbstractString</code>: name of time series</li><li><code>start_time::Union{Nothing, Dates.DateTime} = nothing</code>: If nothing, use the <code>initial_timestamp</code> of the time series. If T is a subtype of <a href="#InfrastructureSystems.Forecast"><code>Forecast</code></a> then <code>start_time</code> must be the first timestamp of a window.</li><li><code>len::Union{Nothing, Int} = nothing</code>: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.</li><li><code>features...</code>: User-defined tags that differentiate multiple time series arrays for the same component attribute, such as different arrays for different scenarios or years</li></ul><p>See also: <a href="#InfrastructureSystems.get_time_series_array-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData"><code>get_time_series_array</code></a>, <a href="#InfrastructureSystems.get_time_series_values-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData"><code>get_time_series_values</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_values" href="#InfrastructureSystems.get_time_series_values"><code>InfrastructureSystems.get_time_series_values</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_time_series_values(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    time_series::StaticTimeSeries;
    ...
) -&gt; Any
get_time_series_values(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    time_series::StaticTimeSeries,
    start_time::Union{Nothing, Dates.DateTime};
    len,
    ignore_scaling_factors
) -&gt; Any
</code></pre><p>Return an vector of timeseries data without timestamps from a cached <code>StaticTimeSeries</code> instance</p><p><strong>Arguments</strong></p><ul><li><code>owner::TimeSeriesOwners</code>: Component or attribute containing the time series</li><li><code>time_series::StaticTimeSeries</code>: subtype of <code>StaticTimeSeries</code> (e.g., <code>SingleTimeSeries</code>)</li><li><code>start_time::Union{Nothing, Dates.DateTime} = nothing</code>: the first timestamp to retrieve. If nothing, use the <code>initial_timestamp</code> of the time series.</li><li><code>len::Union{Nothing, Int} = nothing</code>: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length</li><li><code>ignore_scaling_factors = false</code>: If <code>true</code>, the time-series data will be multiplied by the result of calling the stored <code>scaling_factor_multiplier</code> function on the <code>owner</code></li></ul><p>See also: <a href="#InfrastructureSystems.get_time_series_array"><code>get_time_series_array</code></a>, <a href="#InfrastructureSystems.get_time_series_timestamps"><code>get_time_series_timestamps</code></a>, <a href="api/@ref"><code>StaticTimeSeriesCache</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_values-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, Forecast, Dates.DateTime}" href="#InfrastructureSystems.get_time_series_values-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, Forecast, Dates.DateTime}"><code>InfrastructureSystems.get_time_series_values</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_time_series_values(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    forecast::Forecast,
    start_time::Dates.DateTime;
    len,
    ignore_scaling_factors
) -&gt; Any
</code></pre><p>Return an vector of timeseries data without timestamps for one forecast window from a cached <code>Forecast</code> instance.</p><p><strong>Arguments</strong></p><ul><li><code>owner::TimeSeriesOwners</code>: Component or attribute containing the time series</li><li><code>forecast::Forecast</code>: a concrete subtype of <a href="#InfrastructureSystems.Forecast"><code>Forecast</code></a></li><li><code>start_time::Union{Nothing, Dates.DateTime} = nothing</code>: the first timestamp of one of the forecast windows</li><li><code>len::Union{Nothing, Int} = nothing</code>: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.</li><li><code>ignore_scaling_factors = false</code>: If <code>true</code>, the time-series data will be multiplied by the result of calling the stored <code>scaling_factor_multiplier</code> function on the <code>owner</code></li></ul><p>See also: <a href="#InfrastructureSystems.get_time_series_array-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, Forecast, Dates.DateTime}"><code>get_time_series_array</code></a>, <a href="#InfrastructureSystems.get_time_series_timestamps"><code>get_time_series_timestamps</code></a>, <a href="api/@ref"><code>ForecastCache</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.get_time_series_values-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData" href="#InfrastructureSystems.get_time_series_values-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData"><code>InfrastructureSystems.get_time_series_values</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_time_series_values(
    ::Type{T&lt;:TimeSeriesData},
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute},
    name::AbstractString;
    start_time,
    len,
    ignore_scaling_factors,
    features...
) -&gt; Any
</code></pre><p>Return an vector of timeseries data without timestamps from storage</p><p>If the data size is small and this will be called many times, consider using the version that accepts a cached <code>TimeSeriesData</code> instance.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{T}</code>: type of the time series (a concrete subtype of <code>TimeSeriesData</code>)</li><li><code>owner::TimeSeriesOwners</code>: Component or attribute containing the time series</li><li><code>name::AbstractString</code>: name of time series</li><li><code>start_time::Union{Nothing, Dates.DateTime} = nothing</code>: If nothing, use the <code>initial_timestamp</code> of the time series. If T is a subtype of <a href="#InfrastructureSystems.Forecast"><code>Forecast</code></a> then <code>start_time</code> must be the first timestamp of a window.</li><li><code>len::Union{Nothing, Int} = nothing</code>: Length of time-series to retrieve (i.e. number of timestamps). If nothing, use the entire length.</li><li><code>ignore_scaling_factors = false</code>: If <code>true</code>, the time-series data will be multiplied by the result of calling the stored <code>scaling_factor_multiplier</code> function on the <code>owner</code></li><li><code>features...</code>: User-defined tags that differentiate multiple time series arrays for the same component attribute, such as different arrays for different scenarios or years</li></ul><p>See also: <a href="#InfrastructureSystems.get_time_series_array-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData"><code>get_time_series_array</code></a>, <a href="#InfrastructureSystems.get_time_series_timestamps-Union{Tuple{T}, Tuple{Type{T}, Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}, AbstractString}} where T&lt;:TimeSeriesData"><code>get_time_series_timestamps</code></a>, <a href="#InfrastructureSystems.get_time_series"><code>get_time_series</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.TimeSeriesAssociation" href="#InfrastructureSystems.TimeSeriesAssociation"><code>InfrastructureSystems.TimeSeriesAssociation</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Defines an association between a time series owner (component or supplemental attribute) and the time series metadata.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">association1 = TimeSeriesAssociation(component, time_series)
association2 = TimeSeriesAssociation(component, time_series, scenario = &quot;high&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="InfrastructureSystems.show_time_series-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}}" href="#InfrastructureSystems.show_time_series-Tuple{Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}}"><code>InfrastructureSystems.show_time_series</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show_time_series(
    owner::Union{InfrastructureSystems.InfrastructureSystemsComponent, SupplementalAttribute}
)
</code></pre><p>Show a table with time series data attached to the component.</p></div></section></article><h2 id="Parsing"><a class="docs-heading-anchor" href="#Parsing">Parsing</a><a id="Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PowerSystemTableData-Tuple{AbstractString, Float64, AbstractString}" href="#PowerSystems.PowerSystemTableData-Tuple{AbstractString, Float64, AbstractString}"><code>PowerSystems.PowerSystemTableData</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PowerSystemTableData(
    directory::AbstractString,
    base_power::Float64,
    user_descriptor_file::AbstractString;
    descriptor_file,
    generator_mapping_file,
    timeseries_metadata_file
) -&gt; PowerSystemTableData
</code></pre><p>Reads in all the data stored in csv files The general format for data is     folder:         gen.csv         branch.csv         bus.csv         ..         load.csv</p><p><strong>Arguments</strong></p><ul><li><code>directory::AbstractString</code>: directory containing CSV files</li><li><code>base_power::Float64</code>: base power for System</li><li><code>user_descriptor_file::AbstractString</code>: customized input descriptor file</li><li><code>descriptor_file=POWER_SYSTEM_DESCRIPTOR_FILE</code>: PowerSystems descriptor file</li><li><code>generator_mapping_file=GENERATOR_MAPPING_FILE</code>: generator mapping configuration file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/parsers/power_system_table_data.jl#L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PowerModelsData" href="#PowerSystems.PowerModelsData"><code>PowerSystems.PowerModelsData</code></a> â <span class="docstring-category">Type</span></header><section><div><p>Container for data parsed by PowerModels</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/parsers/power_models_data.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.PowerModelsData-Tuple{Union{IO, String}}" href="#PowerSystems.PowerModelsData-Tuple{Union{IO, String}}"><code>PowerSystems.PowerModelsData</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PowerModelsData(
    file::Union{IO, String};
    kwargs...
) -&gt; PowerModelsData
</code></pre><p>Constructs PowerModelsData from a raw file. Currently Supports MATPOWER and PSSE data files parsed by PowerModels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/parsers/power_models_data.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.TamuSystem-Tuple{AbstractString}" href="#PowerSystems.TamuSystem-Tuple{AbstractString}"><code>PowerSystems.TamuSystem</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TamuSystem(tamu_folder::AbstractString; kwargs...) -&gt; Any
</code></pre><p>Creates a system from a PSS/e .RAW (v33) load flow case, and an associated .csv with MW load time series data. The format is established by the <a href="https://electricgrids.engr.tamu.edu/electric-grid-test-cases/">Texas A&amp;M University Test Case Archive</a></p><p>The general format for data is folder:    [casename].raw    [casename]<em>load</em>time<em>series</em>MW.csv</p><p><strong>Arguments</strong></p><ul><li><code>directory::AbstractString</code>: directory containing RAW and CSV files</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">sys = TamuSystem(
    &quot;./ACTIVSg25k&quot;,
    config_path = &quot;ACTIVSg25k_validation.json&quot;,
    bus_name_formatter = x-&gt;string(x[&quot;name&quot;]*&quot;-&quot;*string(x[&quot;index&quot;])),
    load_name_formatter = x-&gt;strip(join(x[&quot;source_id&quot;], &quot;_&quot;))
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/parsers/TAMU_data.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.add_dyn_injectors!-Tuple{System, AbstractString}" href="#PowerSystems.add_dyn_injectors!-Tuple{System, AbstractString}"><code>PowerSystems.add_dyn_injectors!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_dyn_injectors!(sys::System, dyr_file::AbstractString)
</code></pre><p>Add to a system already created the dynamic components. The system should already be parsed from a .raw file.</p><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">dyr_file = &quot;Example.dyr&quot;
add_dyn_injectors!(sys, dyr_file)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/parsers/psse_dynamic_data.jl#L480">source</a></section></article><h2 id="logging"><a class="docs-heading-anchor" href="#logging">Logging</a><a id="logging-1"></a><a class="docs-heading-anchor-permalink" href="#logging" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PowerSystems.configure_logging-Tuple{}" href="#PowerSystems.configure_logging-Tuple{}"><code>PowerSystems.configure_logging</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">configure_logging(
;
    console_level,
    file_level,
    filename
) -&gt; MultiLogger
</code></pre><p>Creates console and file loggers.</p><p><strong>Note:</strong> Log messages may not be written to the file until flush() or close() is called on the returned logger.</p><p><strong>Arguments</strong></p><ul><li><code>console_level = Logging.Error</code>: level for console messages</li><li><code>file_level = Logging.Info</code>: level for file messages</li><li><code>filename::Union{Nothing, AbstractString} = &quot;power-systems.log&quot;</code>: log file; pass nothing to disable file logging</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">logger = configure_logging(console_level = Logging.Info)
@info &quot;log message&quot;
close(logger)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerSystems.jl/blob/6c55eb23d92cd85d61ac1cce21aac7a9f600d92e/src/utils/logging.jl#L1">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../model_library/generated_TurbineGov/">Â« TurbineGov</a><a class="docs-footer-nextpage" href="../internal/">Internal API Reference Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 2 August 2024 20:49">Friday 2 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
